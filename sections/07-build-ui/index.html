<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>07 - Build UI - Enable Your Vibe</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reset.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/theme/black.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/highlight/monokai.css">
    <link rel="stylesheet" href="../../shared/assets/theme.css">
</head>
<body>
    <!-- Sidebar Navigation -->
    <button id="sidebar-toggle" class="sidebar-toggle"><span></span><span></span><span></span></button>
    <nav id="sidebar" class="sidebar">
        <div class="sidebar-header">
            <h2>Enable Your Vibe</h2>
            <p>Vibe Coding 핸즈온 세션</p>
        </div>
        <ul class="sidebar-sections"></ul>
    </nav>
    <div id="sidebar-overlay" class="sidebar-overlay"></div>

    <div class="reveal"><div class="slides">

        <!-- Slide 1: Title -->
        <section>
            <h1>Build UI</h1>
            <p>UI 만들기</p>
            <p style="margin-top: 2em; font-size: 0.7em; color: var(--ev-text-muted);">
                Section 07 | Hands-on | 30분
            </p>
            <aside class="notes">
                이번 섹션에서는 Genie API를 연동한 채팅 UI를 직접 만들어봅니다.
                FastAPI로 백엔드를 구성하고, HTML/CSS/JS로 프론트엔드를 만들어
                비개발자도 자연어로 데이터를 질의할 수 있는 웹 애플리케이션을 완성합니다.
                빌드 도구 없이 순수한 정적 파일만으로 구현하므로 구조가 매우 심플합니다.
            </aside>
        </section>

        <!-- Slide 2: 학습 목표 -->
        <section>
            <h2>학습 목표</h2>
            <ul>
                <li class="fragment" data-fragment-index="0">FastAPI로 웹 서버를 만드는 기본 구조를 이해한다</li>
                <li class="fragment" data-fragment-index="0">Genie API를 연동한 채팅 UI를 구현한다</li>
                <li class="fragment" data-fragment-index="0">프론트엔드와 백엔드의 통합 패턴을 학습한다</li>
            </ul>
            <div class="emphasis-box fragment" data-fragment-index="0" style="margin-top: 1.5em;">
                <strong>핵심:</strong> 코드를 작성할 줄 모르는 비개발자도 데이터를 질의할 수 있는 웹 UI를 만듭니다
            </div>
            <aside class="notes">
                세 가지 학습 목표를 설명합니다.
                첫째, FastAPI의 기본 구조를 익힙니다. 라우터, 정적 파일 서빙, 요청/응답 모델 등을 다룹니다.
                둘째, Section 04에서 배운 Genie API를 웹 UI와 연동합니다.
                셋째, 프론트엔드(HTML/CSS/JS)와 백엔드(FastAPI)가 어떻게 통신하는지 이해합니다.
                핵심은 비개발자가 사용할 수 있는 인터페이스를 만드는 것입니다.
                CLI나 코드가 아닌, 웹 브라우저에서 바로 데이터를 질의할 수 있게 됩니다.
            </aside>
        </section>

        <!-- Slide 3: 왜 UI가 필요한가? -->
        <section>
            <h2>왜 UI가 필요한가?</h2>
            <div class="columns">
                <div>
                    <h3>CLI/코드 기반</h3>
                    <ul>
                        <li>개발자만 사용 가능</li>
                        <li>환경 설정이 필요</li>
                        <li>Python, 터미널 지식 필수</li>
                        <li>진입 장벽이 높음</li>
                    </ul>
                </div>
                <div>
                    <h3>웹 UI 기반</h3>
                    <ul>
                        <li>누구나 브라우저로 접속</li>
                        <li>별도 설치 불필요</li>
                        <li>직관적인 채팅 인터페이스</li>
                        <li>비개발자도 바로 사용</li>
                    </ul>
                </div>
            </div>
            <div class="emphasis-box fragment" style="margin-top: 1em;">
                <strong>목표:</strong> 데이터 앱을 전사 누구나 사용할 수 있는 형태로 배포
            </div>
            <aside class="notes">
                지금까지 만든 Genie MCP 서버는 Claude Code에서만 사용 가능했습니다.
                개발자에게는 훌륭하지만, 비개발자 동료가 사용하기엔 진입 장벽이 높습니다.
                웹 UI를 만들면 브라우저만 있으면 누구나 자연어로 데이터를 질의할 수 있습니다.
                이것이 Vibe Coding의 진정한 가치입니다 - AI를 통해 누구나 데이터에 접근할 수 있게 만드는 것.
                이번 실습에서는 이 목표를 직접 실현해봅니다.
            </aside>
        </section>

        <!-- Slide 4: 기술 스택 선택 -->
        <section>
            <h2>기술 스택 선택</h2>
            <table>
                <thead>
                    <tr>
                        <th>레이어</th>
                        <th>기술</th>
                        <th>선택 이유</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>백엔드</strong></td>
                        <td><code>FastAPI</code></td>
                        <td>Python 기반, 자동 API 문서, 비동기 지원</td>
                    </tr>
                    <tr>
                        <td><strong>프론트엔드</strong></td>
                        <td><code>HTML + CSS + JS</code></td>
                        <td>빌드 도구 없이 심플하게</td>
                    </tr>
                    <tr>
                        <td><strong>서버 실행</strong></td>
                        <td><code>Uvicorn</code></td>
                        <td>ASGI 서버, 개발/배포 모두 사용</td>
                    </tr>
                    <tr>
                        <td><strong>HTTP 클라이언트</strong></td>
                        <td><code>httpx</code></td>
                        <td>async 지원, requests 호환</td>
                    </tr>
                </tbody>
            </table>
            <div class="emphasis-box fragment" style="margin-top: 1em;">
                React, Vue 같은 프레임워크 없이 <strong>순수 HTML/CSS/JS</strong>로 구현합니다.<br>
                Vibe Coding에서는 복잡한 도구보다 <strong>빠르게 동작하는 것</strong>이 중요합니다.
            </div>
            <aside class="notes">
                기술 스택을 심플하게 유지하는 것이 핵심입니다.
                백엔드는 FastAPI를 사용합니다. Python 기반이므로 이미 익숙하고, 자동 API 문서 생성도 지원합니다.
                프론트엔드는 React나 Vue 같은 프레임워크 없이 순수 HTML, CSS, JavaScript만 사용합니다.
                npm install, webpack 설정 같은 복잡한 과정이 전혀 필요 없습니다.
                Vibe Coding에서는 완벽한 아키텍처보다 빠르게 동작하는 프로토타입이 중요합니다.
                이 스택이면 30분 안에 동작하는 채팅 UI를 만들 수 있습니다.
            </aside>
        </section>

        <!-- Slide 5: FastAPI 기본 구조 -->
        <section>
            <h2>FastAPI 기본 구조</h2>
            <p style="font-size: 0.9em;">Exercise 01에서 구현할 <strong>3가지 엔드포인트</strong></p>
            <table style="font-size: 0.85em;">
                <thead>
                    <tr>
                        <th>메서드</th>
                        <th>경로</th>
                        <th>역할</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>GET</code></td>
                        <td><code>/</code></td>
                        <td>HTML 페이지 응답</td>
                    </tr>
                    <tr>
                        <td><code>GET</code></td>
                        <td><code>/api/health</code></td>
                        <td>서버 상태 확인 (JSON)</td>
                    </tr>
                    <tr>
                        <td><code>POST</code></td>
                        <td><code>/api/echo</code></td>
                        <td>메시지 에코 (JSON 요청/응답)</td>
                    </tr>
                </tbody>
            </table>
            <div class="emphasis-box fragment" style="margin-top: 1em;">
                <strong>핵심 개념:</strong> <code>StaticFiles</code> 마운트, 라우트 데코레이터, Pydantic 모델<br>
                <code>/docs</code> 접속 시 자동 생성된 Swagger UI에서 API를 테스트할 수 있습니다
            </div>
            <aside class="notes">
                FastAPI의 기본 구조를 소개합니다.
                Exercise 01에서 구현할 세 가지 엔드포인트를 미리 보여줍니다.
                GET /는 HTMLResponse로 HTML 페이지를 반환합니다.
                GET /api/health는 서버 상태를 JSON으로 반환하는 헬스체크 엔드포인트입니다.
                POST /api/echo는 사용자가 보낸 메시지를 그대로 반환하는 에코 엔드포인트입니다.
                이 세 가지가 FastAPI의 핵심 패턴을 모두 커버합니다.
                FastAPI의 큰 장점 중 하나는 /docs 경로에 자동으로 Swagger UI가 생성된다는 것입니다.
            </aside>
        </section>

        <!-- Slide 6: 채팅 UI 설계 -->
        <section>
            <h2>채팅 UI 설계</h2>
            <div class="diagram">
<pre style="background: transparent; border: none; box-shadow: none; text-align: center; font-size: 0.95em;">
+------------------------------------------+
|  Header: Genie Chatbot                   |
+------------------------------------------+
|                                          |
|  [Bot] 안녕하세요! 질문해보세요.         |
|                                          |
|        [User] 이번 달 매출은?            |
|                                          |
|  [Bot] 이번 달 총 매출은                 |
|        1,234,567원 입니다.               |
|        SQL: SELECT SUM(amount)...        |
|                                          |
+------------------------------------------+
| [ 질문을 입력하세요...      ] [전송]     |
+------------------------------------------+
</pre>
            </div>
            <div style="margin-top: 0.8em; font-size: 0.85em;">
                <strong>흐름:</strong> 메시지 입력 &rarr; <code>POST /api/chat</code> 호출 &rarr; 로딩 표시 &rarr; 응답 표시
            </div>
            <aside class="notes">
                채팅 UI의 전체 설계입니다.
                상단에 헤더, 중앙에 메시지 영역, 하단에 입력창과 전송 버튼으로 구성됩니다.
                사용자가 메시지를 입력하고 전송 버튼을 누르면, JavaScript가 POST /api/chat API를 호출합니다.
                응답이 올 때까지 로딩 표시를 보여주고, 응답이 오면 봇 메시지로 표시합니다.
                매우 심플한 구조이지만, 실제 서비스에서도 이 패턴이 기본이 됩니다.
            </aside>
        </section>

        <!-- Slide 7: 백엔드 구현 - Chat 엔드포인트 흐름 -->
        <section>
            <h2>백엔드 구현: Chat 엔드포인트 흐름</h2>
            <p style="font-size: 0.9em;"><code>POST /api/chat</code> 의 4단계 처리 흐름</p>
            <div class="diagram">
<pre style="background: transparent; border: none; box-shadow: none; text-align: center; font-size: 0.95em;">
1. 대화 생성          2. 메시지 전송
   (conversation_id)     (message_id)
        |                     |
        v                     v
3. 결과 폴링          4. 응답 파싱
   (최대 60초 대기)      (reply 반환)
</pre>
            </div>
            <ul style="font-size: 0.85em;">
                <li><strong>Step 1:</strong> <code>conversation_id</code>가 없으면 새 대화 생성, 있으면 기존 대화 이어가기</li>
                <li><strong>Step 2:</strong> Genie API에 사용자 메시지 전송 &rarr; <code>message_id</code> 수신</li>
                <li><strong>Step 3:</strong> 상태가 <code>COMPLETED</code>가 될 때까지 폴링</li>
                <li><strong>Step 4:</strong> 결과 파싱 후 <code>ChatResponse</code>로 반환</li>
            </ul>
            <div class="emphasis-box fragment" style="margin-top: 0.8em; font-size: 0.9em;">
                Section 04에서 배운 Genie API 패턴을 FastAPI 엔드포인트로 감싸는 것이 핵심
            </div>
            <aside class="notes">
                백엔드의 핵심 로직을 흐름도로 정리합니다.
                Section 04에서 배운 Genie API 호출 패턴과 동일합니다.
                차이점은 이것을 FastAPI 엔드포인트로 감싸서 HTTP API로 노출한다는 것입니다.
                conversation_id를 클라이언트에 반환하여 같은 대화를 이어갈 수 있게 합니다.
                스켈레톤 파일에 TODO로 각 단계가 표시되어 있으니, Claude Code에게 구현을 요청하면 됩니다.
                폴링 패턴은 이전 섹션에서 이미 익숙해졌을 것입니다.
            </aside>
        </section>

        <!-- Slide 8: 프론트엔드 구현 -->
        <section>
            <h2>프론트엔드 구현</h2>
            <p style="font-size: 0.9em;">Claude Code가 <code>static/GUIDE.md</code>의 요구사항을 읽고 3개 파일을 생성합니다</p>
            <table style="font-size: 0.85em;">
                <thead>
                    <tr>
                        <th>파일</th>
                        <th>역할</th>
                        <th>핵심 포인트</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>index.html</code></td>
                        <td>페이지 구조</td>
                        <td>헤더, 메시지 영역, 입력창</td>
                    </tr>
                    <tr>
                        <td><code>style.css</code></td>
                        <td>다크 테마 스타일</td>
                        <td><code>#1a1a2e</code> 배경, <code>#e94560</code> 강조</td>
                    </tr>
                    <tr>
                        <td><code>app.js</code></td>
                        <td>채팅 로직</td>
                        <td><code>fetch</code>로 <code>/api/chat</code> 호출, 응답 표시</td>
                    </tr>
                </tbody>
            </table>
            <div class="emphasis-box fragment" style="margin-top: 1em; font-size: 0.9em;">
                <strong>GUIDE.md</strong>에 UI 레이아웃, 색상, 인터랙션 요구사항이 정의되어 있습니다.<br>
                Claude Code에게 이 파일을 읽고 구현하도록 요청하면 됩니다.
            </div>
            <aside class="notes">
                프론트엔드는 세 파일로 구성됩니다: index.html, style.css, app.js.
                직접 코드를 작성하는 대신, GUIDE.md에 요구사항이 정리되어 있습니다.
                Claude Code에게 GUIDE.md를 읽고 파일을 생성해달라고 요청하면 됩니다.
                GUIDE.md에는 UI 레이아웃, 색상 테마, 인터랙션 패턴 등이 명시되어 있습니다.
                React나 Vue 없이도 이 정도의 인터랙티브 UI를 만들 수 있습니다.
                Vibe Coding의 핵심은 요구사항을 잘 정리하고 AI에게 구현을 맡기는 것입니다.
            </aside>
        </section>

        <!-- Slide 9: SSE로 실시간 스트리밍 (개념 소개) -->
        <section>
            <h2>SSE(Server-Sent Events)로 실시간 스트리밍</h2>
            <div class="columns">
                <div>
                    <h3>현재 방식: 폴링</h3>
                    <ul>
                        <li>요청 &rarr; 전체 응답 한 번에 수신</li>
                        <li>응답이 올 때까지 로딩 대기</li>
                        <li>구현이 단순</li>
                        <li>사용자 경험이 다소 답답할 수 있음</li>
                    </ul>
                </div>
                <div>
                    <h3>개선 방식: SSE</h3>
                    <ul>
                        <li>서버에서 클라이언트로 실시간 푸시</li>
                        <li>글자가 한 글자씩 나타나는 효과</li>
                        <li>ChatGPT와 같은 스트리밍 UX</li>
                        <li>체감 응답 속도 크게 향상</li>
                    </ul>
                </div>
            </div>
            <pre><code class="python" data-trim data-noescape>
from fastapi.responses import StreamingResponse

@app.post("/api/chat/stream")
async def chat_stream(req: ChatRequest):
    async def event_generator():
        yield f"data: {json.dumps({'type': 'status', 'content': '질의 중...'})}\n\n"
        # ... Genie API 호출 및 결과 스트리밍 ...
        yield f"data: {json.dumps({'type': 'result', 'content': reply})}\n\n"
    return StreamingResponse(event_generator(), media_type="text/event-stream")
            </code></pre>
            <aside class="notes">
                현재 구현은 폴링 방식으로, 전체 응답이 올 때까지 기다려야 합니다.
                SSE(Server-Sent Events)를 사용하면 서버에서 클라이언트로 실시간으로 데이터를 푸시할 수 있습니다.
                ChatGPT처럼 글자가 한 글자씩 나타나는 효과를 구현할 수 있습니다.
                이번 실습에서는 기본적인 폴링 방식을 구현하고, SSE는 개념만 소개합니다.
                SSE 구현은 FastAPI의 StreamingResponse를 사용하면 됩니다.
                프론트엔드에서는 EventSource API로 서버의 이벤트를 수신합니다.
                다음 단계로 개선하고 싶은 분은 이 패턴을 참고하세요.
            </aside>
        </section>

        <!-- Slide 10: 전체 아키텍처 다이어그램 -->
        <section>
            <h2>전체 아키텍처</h2>
            <div class="diagram">
<pre style="background: transparent; border: none; box-shadow: none; text-align: center; font-size: 0.95em;">
+-------------+          +----------------+          +------------------+
|             |  fetch   |                |  httpx   |                  |
|   Browser   |--------->|    FastAPI     |--------->|    Genie API     |
|  (HTML/JS)  |<---------|   (Python)     |<---------|  (Databricks)    |
|             |   JSON   |                |   JSON   |                  |
+-------------+          +----------------+          +------------------+
                          |
                          | StaticFiles
                          |
                    +-------------+
                    | static/     |
                    | index.html  |
                    | style.css   |
                    | app.js      |
                    +-------------+
</pre>
            </div>
            <div class="emphasis-box fragment" style="margin-top: 0.8em; font-size: 0.9em;">
                <strong>핵심 포인트:</strong>
                FastAPI가 프록시 역할 &mdash; 프론트엔드는 Genie API를 직접 호출하지 않음<br>
                (토큰 보안 + CORS 회피 + 비즈니스 로직 캡슐화)
            </div>
            <aside class="notes">
                전체 아키텍처를 정리합니다.
                브라우저에서 JavaScript의 fetch로 FastAPI 서버에 요청을 보냅니다.
                FastAPI 서버는 httpx를 사용하여 Databricks Genie API를 호출합니다.
                결과를 JSON으로 변환하여 브라우저에 반환합니다.
                FastAPI는 정적 파일도 서빙하므로, 별도의 웹 서버가 필요 없습니다.
                프론트엔드가 Genie API를 직접 호출하지 않는 이유가 세 가지 있습니다.
                첫째, 토큰을 브라우저에 노출하면 보안 위험이 있습니다.
                둘째, 브라우저의 CORS 정책으로 외부 API 직접 호출이 제한될 수 있습니다.
                셋째, 폴링 같은 비즈니스 로직을 서버에서 처리하는 것이 깔끔합니다.
            </aside>
        </section>

        <!-- Slide 11: 실습 안내 - Exercise 01 -->
        <section>
            <h2>실습: Exercise 01 - FastAPI 기본 서버</h2>
            <div style="text-align: left; font-size: 0.9em;">
                <p><strong>Step 1.</strong> 스켈레톤 파일의 TODO 확인</p>
                <pre><code class="bash" data-trim>
cat exercise_01_fastapi_basic.py  # TODO 주석 확인
                </code></pre>
                <p><strong>Step 2.</strong> Claude Code에게 구현 요청</p>
                <pre><code class="text" data-trim>
> exercise_01_fastapi_basic.py의 TODO를 구현해줘
                </code></pre>
                <p><strong>Step 3.</strong> 실행 및 테스트</p>
                <pre><code class="bash" data-trim>
python exercise_01_fastapi_basic.py
# http://localhost:8000      → HTML 페이지
# http://localhost:8000/docs → Swagger UI에서 API 테스트
                </code></pre>
            </div>
            <div class="emphasis-box fragment" style="margin-top: 0.8em; font-size: 0.9em;">
                <strong>구현 대상:</strong> <code>GET /</code>, <code>GET /api/health</code>, <code>POST /api/echo</code> 3개 엔드포인트
            </div>
            <aside class="notes">
                Exercise 01은 FastAPI 기본 서버입니다. FastAPI가 처음인 분들을 위한 워밍업입니다.
                스켈레톤 파일에 TODO 주석이 있으니 먼저 구조를 확인합니다.
                그런 다음 Claude Code에게 TODO를 구현해달라고 요청합니다.
                서버를 실행하고 브라우저에서 접속해보세요.
                /docs에서 Swagger UI로 API를 직접 테스트할 수 있습니다.
            </aside>
        </section>

        <!-- Slide 12: 실습 안내 - Exercise 02 -->
        <section>
            <h2>실습: Exercise 02 - Genie 채팅 UI</h2>
            <div style="text-align: left; font-size: 0.85em;">
                <p><strong>Step 1.</strong> 환경변수 설정</p>
                <pre><code class="bash" data-trim>
cd exercise_02_genie_chatbot
cp .env.example .env  # DATABRICKS_HOST, TOKEN, SPACE_ID 설정
                </code></pre>
                <p><strong>Step 2.</strong> Claude Code에게 백엔드 구현 요청</p>
                <pre><code class="text" data-trim>
> app.py의 chat 엔드포인트 TODO를 구현해줘
                </code></pre>
                <p><strong>Step 3.</strong> Claude Code에게 프론트엔드 생성 요청</p>
                <pre><code class="text" data-trim>
> static/GUIDE.md의 요구사항을 읽고 index.html, style.css, app.js를 생성해줘
                </code></pre>
                <p><strong>Step 4.</strong> 실행 및 테스트</p>
                <pre><code class="bash" data-trim>
python app.py
# http://localhost:8000 → 채팅 UI에서 자연어 데이터 질의
                </code></pre>
            </div>
            <aside class="notes">
                Exercise 02는 Genie API를 연동한 완전한 채팅 UI입니다.
                먼저 .env 파일에 Databricks 접속 정보를 설정합니다.
                백엔드는 app.py에 TODO가 있으니 Claude Code에게 구현을 요청합니다.
                프론트엔드는 GUIDE.md에 요구사항이 정리되어 있습니다.
                Claude Code에게 GUIDE.md를 읽고 세 개 파일을 생성해달라고 요청합니다.
                서버를 실행하고 브라우저에서 자연어로 데이터를 질의해보세요.
                Databricks 환경이 없는 분은 코드 구조를 분석하는 것만으로도 충분합니다.
            </aside>
        </section>

        <!-- Slide 13: 정리 & Q&A -->
        <section>
            <h2>정리 & Q&A</h2>
            <ul>
                <li><strong>FastAPI</strong>: Python으로 빠르게 웹 서버를 만들 수 있는 프레임워크</li>
                <li><strong>프록시 패턴</strong>: FastAPI가 Genie API 호출을 대행 (보안 + CORS + 로직 캡슐화)</li>
                <li><strong>정적 파일 서빙</strong>: 빌드 도구 없이 HTML/CSS/JS를 직접 서빙</li>
                <li><strong>Claude Code 워크플로우</strong>: 스켈레톤 + TODO &rarr; Claude Code 구현 &rarr; 테스트</li>
                <li><strong>GUIDE.md 패턴</strong>: 요구사항 문서로 AI에게 UI 생성을 지시</li>
            </ul>
            <div class="emphasis-box" style="margin-top: 1.5em;">
                <strong>다음 섹션:</strong> Deploy to Databricks &mdash; 만든 앱을 Databricks에 배포하기
            </div>
            <aside class="notes">
                이번 섹션의 핵심을 정리합니다.
                FastAPI로 웹 서버를 만들고, 정적 파일을 서빙하는 방법을 배웠습니다.
                Genie API를 프록시하는 패턴으로 보안과 기능을 모두 확보했습니다.
                스켈레톤 파일에 TODO를 정의하고 Claude Code에게 구현을 맡기는 워크플로우를 실습했습니다.
                GUIDE.md로 요구사항을 정리하면 Claude Code가 프론트엔드를 통째로 생성할 수 있습니다.
                다음 섹션에서는 이렇게 만든 앱을 Databricks 환경에 배포하는 방법을 다룹니다.
                질문이 있으시면 자유롭게 해주세요.
            </aside>
        </section>

    </div></div>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/notes/notes.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/highlight/highlight.js"></script>
    <script>
        Reveal.initialize({ hash: true, slideNumber: true, plugins: [RevealNotes, RevealHighlight] });
    </script>
    <script src="../../shared/scripts/sidebar.js"></script>
    <script src="../../shared/scripts/copy-code.js"></script>
</body>
</html>
