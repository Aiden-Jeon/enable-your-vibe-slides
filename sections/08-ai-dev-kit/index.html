<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>08 - AI Dev Kit - Enable Your Vibe</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reset.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/theme/black.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/highlight/monokai.css">
    <link rel="stylesheet" href="../../shared/assets/theme.css">
    <style>
        /* Section-specific styles */
        .reveal .subtitle {
            color: var(--ev-accent-light);
            font-size: 1.2em;
            margin-top: 0.2em;
        }
        .reveal .section-number {
            font-size: 0.5em;
            color: var(--ev-text-muted);
            letter-spacing: 0.2em;
            text-transform: uppercase;
        }
        .reveal .objective-list li {
            padding: 0.4em 0;
            font-size: 0.95em;
        }
        .reveal .objective-list li::marker {
            color: var(--ev-accent);
        }
        .reveal .component-card {
            background: var(--ev-bg-alt);
            border-radius: 10px;
            padding: 1em 1.2em;
            margin: 0.5em 0;
            border: 1px solid #333;
        }
        .reveal .component-card h4 {
            color: var(--ev-accent-light);
            margin: 0 0 0.3em 0;
            font-size: 1em;
        }
        .reveal .component-card p {
            margin: 0;
            font-size: 0.85em;
            color: var(--ev-text-muted);
        }
        .reveal .component-card code {
            font-size: 0.9em;
        }
        .reveal .deploy-flow {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.6em;
            margin: 1.2em 0;
            flex-wrap: nowrap;
        }
        .reveal .deploy-flow .flow-step {
            background: var(--ev-bg-alt);
            border: 1px solid var(--ev-accent);
            border-radius: 10px;
            padding: 0.6em 0.8em;
            text-align: center;
            min-width: 100px;
        }
        .reveal .deploy-flow .flow-step .step-label {
            font-size: 0.75em;
            color: var(--ev-text-muted);
            display: block;
            margin-top: 0.2em;
        }
        .reveal .deploy-flow .flow-arrow {
            color: var(--ev-accent);
            font-size: 1.5em;
        }
        .reveal .badge {
            display: inline-block;
            background: var(--ev-accent);
            color: white;
            font-size: 0.6em;
            padding: 0.2em 0.6em;
            border-radius: 20px;
            vertical-align: middle;
            margin-left: 0.5em;
        }
        .reveal .arch-overview {
            background: var(--ev-code-bg);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 1.5em;
            font-family: "Courier New", monospace;
            font-size: 0.7em;
            line-height: 1.5;
            text-align: center;
        }
        .reveal .tracing-box {
            background: var(--ev-bg-alt);
            border-left: 4px solid var(--ev-accent);
            border-radius: 0 8px 8px 0;
            padding: 0.8em 1.2em;
            margin: 0.6em 0;
        }
        .reveal .tracing-box h4 {
            color: var(--ev-accent-light);
            margin: 0 0 0.2em 0;
            font-size: 0.95em;
        }
        .reveal .tracing-box p {
            margin: 0;
            font-size: 0.8em;
            color: var(--ev-text-muted);
        }
        .reveal .category-table {
            width: 100%;
            font-size: 0.7em;
            border-collapse: collapse;
        }
        .reveal .category-table th {
            background: var(--ev-bg-alt);
            color: var(--ev-accent-light);
            padding: 0.4em 0.6em;
            text-align: left;
            border-bottom: 2px solid var(--ev-accent);
        }
        .reveal .category-table td {
            padding: 0.35em 0.6em;
            border-bottom: 1px solid #333;
        }
        .reveal .category-table td:first-child {
            color: var(--ev-accent-light);
            font-weight: 600;
            white-space: nowrap;
        }
        .reveal .mini-card {
            background: var(--ev-bg-alt);
            border-radius: 8px;
            padding: 0.6em 0.8em;
            margin: 0.3em 0;
            border: 1px solid #333;
            font-size: 0.8em;
        }
        .reveal .mini-card strong {
            color: var(--ev-accent-light);
        }
        .reveal .install-box {
            background: var(--ev-code-bg);
            border: 1px solid var(--ev-accent);
            border-radius: 8px;
            padding: 0.5em 1em;
            margin: 0.25em 0;
            text-align: center;
        }
        .reveal .install-box pre {
            margin: 0;
            box-shadow: none;
            border: none;
            font-size: 0.5em;
        }
        .reveal .install-box pre code {
            padding: 0.5em 0.8em;
            line-height: 1.3;
        }
        .reveal .mapping-row {
            display: flex;
            align-items: center;
            gap: 0.8em;
            margin: 0.4em 0;
            font-size: 0.8em;
        }
        .reveal .mapping-row .map-from {
            background: var(--ev-bg-alt);
            border: 1px solid #333;
            border-radius: 6px;
            padding: 0.3em 0.6em;
            min-width: 140px;
            text-align: center;
        }
        .reveal .mapping-row .map-arrow {
            color: var(--ev-accent);
        }
        .reveal .mapping-row .map-to {
            background: var(--ev-bg-alt);
            border: 1px solid var(--ev-accent);
            border-radius: 6px;
            padding: 0.3em 0.6em;
            min-width: 180px;
            text-align: center;
            color: var(--ev-accent-light);
        }
    </style>
</head>
<body>
    <!-- Sidebar Navigation -->
    <button id="sidebar-toggle" class="sidebar-toggle"><span></span><span></span><span></span></button>
    <nav id="sidebar" class="sidebar">
        <div class="sidebar-header">
            <h2>Enable Your Vibe</h2>
            <p>Vibe Coding 핸즈온 세션</p>
        </div>
        <ul class="sidebar-sections"></ul>
    </nav>
    <div id="sidebar-overlay" class="sidebar-overlay"></div>

    <div class="reveal">
        <div class="slides">

            <!-- Slide 1: Title -->
            <section>
                <p class="section-number">Section 08</p>
                <h1>AI Dev Kit</h1>
                <p class="subtitle">Databricks AI Dev Kit</p>
                <br>
                <p style="font-size: 0.7em; color: var(--ev-text-muted);">
                    Enable Your Vibe &mdash; AI-Powered Development Hands-on
                </p>
                <p style="font-size: 0.6em; color: var(--ev-text-muted);">
                    30분 | 강의+데모
                </p>
                <aside class="notes">
                    마지막 섹션인 섹션 8을 시작합니다. 이 세션에서는 Databricks AI Dev Kit를 소개합니다.
                    지금까지 Claude Code와 MCP를 활용한 개발 방법을 배웠다면,
                    이제는 이 모든 것을 프로덕션 수준으로 통합하는 프레임워크를 알아봅니다.
                    AI Dev Kit의 5대 구성 요소부터 ChatAgent, MLflow Tracing까지 전체 그림을 보여드리겠습니다.
                </aside>
            </section>

            <!-- Slide 2: 학습 목표 -->
            <section>
                <h2>학습 목표</h2>
                <ol class="objective-list">
                    <li class="fragment fade-up" data-fragment-index="0">
                        <strong>AI Dev Kit</strong>의 5대 구성 요소와 전체 아키텍처를 이해한다
                    </li>
                    <li class="fragment fade-up" data-fragment-index="0">
                        <strong>databricks-mcp</strong> 서버의 도구 카테고리와 활용법을 파악한다
                    </li>
                    <li class="fragment fade-up" data-fragment-index="0">
                        <strong>databricks-skills</strong>의 구조와 Claude Code 연동 방법을 학습한다
                    </li>
                    <li class="fragment fade-up" data-fragment-index="0">
                        <strong>databricks-agents</strong>의 <code>ChatAgent</code> 인터페이스를 학습한다
                    </li>
                    <li class="fragment fade-up" data-fragment-index="0">
                        <strong>MLflow Tracing</strong>을 활용한 에이전트 모니터링 방법을 파악한다
                    </li>
                </ol>
                <aside class="notes">
                    이 세션이 끝나면 참가자들은 다섯 가지를 이해하게 됩니다.
                    첫째, AI Dev Kit의 5대 구성 요소와 전체 아키텍처.
                    둘째, MCP 서버가 제공하는 50개 이상의 도구 카테고리.
                    셋째, Skills가 Claude Code와 어떻게 연동되는지.
                    넷째, ChatAgent 표준 인터페이스로 에이전트를 정의하는 방법.
                    다섯째, MLflow Tracing으로 에이전트 동작을 추적하는 방법입니다.
                </aside>
            </section>

            <!-- Slide 3: [NEW] AI Dev Kit 전체 그림 -->
            <section>
                <h2>AI Dev Kit 전체 그림</h2>
                <p style="font-size: 0.85em; margin-bottom: 0.6em;">
                    <a href="https://github.com/databricks-solutions/ai-dev-kit" style="color: var(--ev-accent-light);">databricks-solutions/ai-dev-kit</a> &mdash; 오픈소스 통합 프레임워크
                </p>
                <div class="fragment fade-up" style="background: var(--ev-code-bg); border: 1px solid var(--ev-accent); border-radius: 8px; padding: 1.2em 2em; width: 100%; box-sizing: border-box;">
                    <div style="text-align: center; margin-bottom: 0.8em;">
                        <span style="color: var(--ev-accent-light); font-size: 1.1em; font-weight: 600;">Databricks AI Dev Kit</span>
                    </div>
                    <table style="border-collapse: collapse; font-family: 'Courier New', monospace; font-size: 0.75em; width: 100%;">
                        <tr><td style="padding: 0.3em 0; width: 40%; text-align: right; padding-right: 2em;"><span style="color: #4ecdc4;">[tools-core]</span></td><td style="padding: 0.3em 0; color: var(--ev-text-muted);">SDK 래퍼 &amp; 공통 도구</td></tr>
                        <tr><td style="padding: 0.3em 0; text-align: right; padding-right: 2em;"><span style="color: #ffe66d;">[mcp-server]</span></td><td style="padding: 0.3em 0; color: var(--ev-text-muted);">MCP 프로토콜 서버</td></tr>
                        <tr><td style="padding: 0.3em 0; text-align: right; padding-right: 2em;"><span style="color: #a8e6cf;">[skills]</span></td><td style="padding: 0.3em 0; color: var(--ev-text-muted);">프롬프트 &amp; 지식 팩</td></tr>
                        <tr><td style="padding: 0.3em 0; text-align: right; padding-right: 2em;"><span style="color: #ff6b6b;">[builder-app]</span></td><td style="padding: 0.3em 0; color: var(--ev-text-muted);">대화형 빌더 UI</td></tr>
                        <tr><td style="padding: 0.3em 0; text-align: right; padding-right: 2em;"><span style="color: #c9b1ff;">[ai-dev-project]</span></td><td style="padding: 0.3em 0; color: var(--ev-text-muted);">프로젝트 템플릿</td></tr>
                    </table>
                </div>
                <div class="fragment fade-up" style="margin-top: 0.8em;">
                    <p style="font-size: 0.75em; color: var(--ev-text-muted); text-align: center;">
                        Claude Code + Databricks를 하나의 워크플로우로 연결하는 5대 구성 요소
                    </p>
                </div>
                <aside class="notes">
                    Databricks AI Dev Kit는 GitHub의 databricks-solutions/ai-dev-kit 레포에서 오픈소스로 공개된 프레임워크입니다.
                    5개의 주요 구성 요소로 이루어져 있습니다.
                    tools-core는 Databricks SDK를 래핑한 공통 도구 라이브러리입니다.
                    mcp-server는 이 도구들을 MCP 프로토콜로 노출하는 서버입니다.
                    skills는 Claude Code에서 사용할 수 있는 프롬프트와 지식 팩입니다.
                    builder-app은 대화형으로 프로젝트를 설정할 수 있는 UI입니다.
                    ai-dev-project는 새 프로젝트를 시작할 때 사용하는 템플릿입니다.
                </aside>
            </section>

            <!-- Slide 4: [NEW] 5대 구성 요소 상세 -->
            <section>
                <h2>5대 구성 요소</h2>
                <div class="columns">
                    <div>
                        <div class="component-card fragment fade-up">
                            <h4>databricks-tools-core</h4>
                            <p>Databricks SDK 래퍼 &mdash; SQL, Compute, Jobs 등 50+ 도구</p>
                        </div>
                        <div class="component-card fragment fade-up">
                            <h4>databricks-mcp</h4>
                            <p>FastMCP 기반 MCP 서버 &mdash; tools-core를 MCP 프로토콜로 노출</p>
                        </div>
                        <div class="component-card fragment fade-up">
                            <h4>databricks-skills</h4>
                            <p>25+ SKILL.md 팩 &mdash; 파이프라인, 대시보드, Genie 등 작업별 가이드</p>
                        </div>
                    </div>
                    <div>
                        <div class="component-card fragment fade-up">
                            <h4>databricks-builder-app</h4>
                            <p>대화형 빌더 UI &mdash; 스킬 선택, 프로젝트 스캐폴딩, 원클릭 설정</p>
                        </div>
                        <div class="component-card fragment fade-up" style="border-color: var(--ev-accent);">
                            <h4>databricks-ai-dev-project</h4>
                            <p>프로젝트 템플릿 &mdash; CLAUDE.md, MCP 설정, Skills 포함 스타터 킷</p>
                        </div>
                    </div>
                </div>
                <aside class="notes">
                    각 구성 요소를 좀 더 자세히 살펴봅시다.
                    tools-core는 Databricks SDK를 감싼 래퍼로, SQL 실행, 클러스터 관리, 잡 관리 등 50개 이상의 도구를 제공합니다.
                    mcp-server는 FastMCP 기반으로 tools-core의 도구들을 MCP 프로토콜로 노출합니다. 오늘 배운 FastMCP와 동일한 패턴입니다.
                    skills는 25개 이상의 SKILL.md 파일로, 파이프라인 구축, 대시보드 생성 등 작업별 가이드를 제공합니다.
                    builder-app은 웹 UI에서 대화형으로 프로젝트를 설정할 수 있게 해줍니다.
                    ai-dev-project는 새 프로젝트를 시작할 때 CLAUDE.md, MCP 설정, Skills가 포함된 템플릿입니다.
                </aside>
            </section>

            <!-- Slide 5: [NEW] MCP Server 아키텍처 -->
            <section>
                <h2>MCP Server 아키텍처</h2>
                <p style="font-size: 0.85em; margin-bottom: 0.6em;">
                    Claude Code &rarr; <strong>databricks-mcp</strong> &rarr; Databricks Workspace
                </p>
                <div class="deploy-flow fragment fade-up">
                    <div class="flow-step">
                        <strong>Claude Code</strong>
                        <span class="step-label">MCP Client</span>
                    </div>
                    <span class="flow-arrow">&rarr;</span>
                    <div class="flow-step">
                        <strong>FastMCP</strong>
                        <span class="step-label">MCP Protocol</span>
                    </div>
                    <span class="flow-arrow">&rarr;</span>
                    <div class="flow-step">
                        <strong>tools-core</strong>
                        <span class="step-label">SDK Wrapper</span>
                    </div>
                    <span class="flow-arrow">&rarr;</span>
                    <div class="flow-step">
                        <strong>Workspace</strong>
                        <span class="step-label">Databricks API</span>
                    </div>
                </div>
                <pre class="fragment fade-up"><code class="language-json">// .claude/settings.json
{
  "mcpServers": {
    "databricks": {
      "command": "uvx",
      "args": ["databricks-mcp@latest"]
    }
  }
}</code></pre>
                <div class="fragment fade-up" style="margin-top: 0.6em;">
                    <div class="emphasis-box" style="font-size: 0.8em;">
                        <strong>핵심:</strong> Section 03에서 배운 MCP 아키텍처가 그대로 적용됩니다
                    </div>
                </div>
                <aside class="notes">
                    MCP 서버의 아키텍처를 살펴봅시다.
                    Claude Code가 MCP 클라이언트로서 databricks-mcp 서버에 연결합니다.
                    서버는 FastMCP로 구현되어 있고, 내부적으로 tools-core를 통해 Databricks SDK를 호출합니다.
                    설정은 claude settings.json에 MCP 서버를 등록하면 끝입니다.
                    uvx로 최신 버전을 자동 설치하고 실행할 수 있습니다.
                    Section 03에서 배운 MCP 아키텍처가 그대로 적용되는 것을 볼 수 있습니다.
                </aside>
            </section>

            <!-- Slide 6: [NEW] 50+ 도구 카테고리 -->
            <section>
                <h2>50+ 도구 카테고리</h2>
                <p style="font-size: 0.8em; margin-bottom: 0.5em; color: var(--ev-text-muted);">
                    databricks-mcp가 제공하는 주요 도구 카테고리
                </p>
                <table class="category-table fragment fade-up">
                    <thead>
                        <tr><th>카테고리</th><th>주요 도구</th><th>활용 예시</th></tr>
                    </thead>
                    <tbody>
                        <tr><td>SQL</td><td>execute_sql, get_table_schema</td><td>데이터 조회 &amp; 스키마 탐색</td></tr>
                        <tr><td>Compute</td><td>list_clusters, create_cluster</td><td>클러스터 관리</td></tr>
                        <tr><td>Jobs</td><td>create_job, run_job</td><td>워크플로우 자동화</td></tr>
                        <tr><td>Files</td><td>read_file, write_file</td><td>DBFS/UC Volume 파일 관리</td></tr>
                        <tr><td>Secrets</td><td>get_secret, put_secret</td><td>자격 증명 관리</td></tr>
                        <tr><td>Serving</td><td>create_endpoint, query_endpoint</td><td>모델 서빙</td></tr>
                        <tr><td>Pipelines</td><td>create_pipeline, start_pipeline</td><td>DLT 파이프라인</td></tr>
                        <tr><td>Genie</td><td>query_genie_space</td><td>자연어 데이터 조회</td></tr>
                        <tr><td>Vector Search</td><td>query_vector_index</td><td>시맨틱 검색</td></tr>
                        <tr><td>Dashboard</td><td>create_dashboard</td><td>AI SQL 대시보드</td></tr>
                    </tbody>
                </table>
                <div class="fragment fade-up" style="margin-top: 0.5em; text-align: center;">
                    <p style="font-size: 0.75em; color: var(--ev-text-muted);">
                        Section 04에서 직접 만든 Genie MCP가 이미 내장되어 있습니다!
                    </p>
                </div>
                <aside class="notes">
                    databricks-mcp가 제공하는 도구 카테고리를 살펴봅시다.
                    SQL로 데이터를 조회하고 스키마를 탐색할 수 있고,
                    Compute로 클러스터를 관리하고, Jobs로 워크플로우를 자동화할 수 있습니다.
                    Files로 DBFS나 UC Volume의 파일을 관리하고,
                    Serving으로 모델 서빙 엔드포인트를 생성하고 쿼리할 수 있습니다.
                    주목할 점은, Section 04에서 우리가 직접 만든 Genie MCP가 이미 내장되어 있다는 것입니다.
                    우리가 배운 패턴이 실제 프로덕션 도구에도 동일하게 적용됩니다.
                </aside>
            </section>

            <!-- Slide 7: [NEW] databricks-skills -->
            <section>
                <h2>databricks-skills</h2>
                <p style="font-size: 0.85em; margin-bottom: 0.5em;">
                    6개 카테고리, <strong>25+ 스킬</strong> &mdash; <code>.claude/skills/</code>에 설치
                </p>
                <div class="columns">
                    <div class="fragment fade-up" data-fragment-index="0" style="display: flex; gap: 2em;">
                        <div>
                            <div class="mini-card">
                                <strong>Data Engineering</strong><br>
                                DLT 파이프라인, ETL 작업, Delta 테이블 관리
                            </div>
                            <div class="mini-card">
                                <strong>Analytics</strong><br>
                                SQL 대시보드, Genie Space, 데이터 분석
                            </div>
                            <div class="mini-card">
                                <strong>ML &amp; AI</strong><br>
                                모델 학습, MLflow 실험, Feature Store
                            </div>
                        </div>
                        <div>
                            <div class="mini-card">
                                <strong>Governance</strong><br>
                                Unity Catalog, 접근 제어, 데이터 리니지
                            </div>
                            <div class="mini-card">
                                <strong>Infrastructure</strong><br>
                                클러스터, Jobs, 서빙 엔드포인트
                            </div>
                            <div class="mini-card">
                                <strong>Agent Development</strong><br>
                                ChatAgent, 도구 연동, 배포 파이프라인
                            </div>
                        </div>
                    </div>
                </div>
                <aside class="notes">
                    databricks-skills는 6개 카테고리에 걸쳐 25개 이상의 스킬을 제공합니다.
                    Data Engineering 스킬로 DLT 파이프라인을 만들고,
                    Analytics 스킬로 SQL 대시보드나 Genie Space를 설정할 수 있습니다.
                    ML & AI 스킬로 모델 학습과 MLflow 실험을 관리하고,
                    Governance 스킬로 Unity Catalog 설정을 자동화할 수 있습니다.
                    중요한 점은, Section 05에서 배운 SKILL.md 형식 그대로라는 것입니다.
                    우리가 배운 Skills 개념이 프로덕션 수준에서도 동일하게 적용됩니다.
                </aside>
            </section>

            <!-- Slide 8: [NEW] Skills + MCP Tools 통합 -->
            <section>
                <h2>Skills + MCP Tools 통합</h2>
                <p style="font-size: 0.85em; margin-bottom: 0.6em;">
                    <strong>Skills = 지식</strong> (무엇을, 어떻게) + <strong>MCP Tools = 실행</strong> (실제 동작)
                </p>
                <div class="component-card fragment fade-up">
                    <h4>예시: "DLT 파이프라인 만들어줘"</h4>
                    <p style="color: var(--ev-text); font-size: 0.8em; margin-top: 0.5em;">
                        1. <span style="color: #a8e6cf;">Skill</span> &mdash; <code>create-dlt-pipeline</code> 스킬이 파이프라인 구조, 모범 사례, 설정 가이드 제공<br>
                        2. <span style="color: #ffe66d;">MCP Tool</span> &mdash; <code>create_pipeline</code>, <code>execute_sql</code> 도구가 실제 API 호출 수행<br>
                        3. <span style="color: #4ecdc4;">결과</span> &mdash; 실제 동작하는 DLT 파이프라인이 Databricks에 생성됨
                    </p>
                </div>
                <div class="fragment fade-up" style="margin-top: 0.8em;">
                    <div class="emphasis-box" style="font-size: 0.8em;">
                        <strong>핵심 인사이트:</strong>
                        Skills가 "전문가의 지식"을 제공하고, MCP Tools가 "손과 발"이 되어 실행합니다.
                        <br>둘이 합쳐지면 Claude Code가 Databricks 전문가처럼 동작합니다.
                    </div>
                </div>
                <aside class="notes">
                    Skills와 MCP Tools가 어떻게 함께 동작하는지 구체적인 예시로 살펴봅시다.
                    예를 들어 "DLT 파이프라인 만들어줘"라고 요청하면,
                    먼저 create-dlt-pipeline 스킬이 파이프라인의 구조, 모범 사례, 설정 방법을 Claude에게 알려줍니다.
                    그런 다음 MCP Tools인 create_pipeline, execute_sql 등이 실제 Databricks API를 호출합니다.
                    결과적으로 실제 동작하는 DLT 파이프라인이 만들어집니다.
                    Skills는 전문가의 지식을, MCP Tools는 실행 능력을 제공하는 것입니다.
                </aside>
            </section>

            <!-- Slide 9: [NEW] 설치 방법 -->
            <section>
                <h2 style="margin-bottom: 0.4em;">설치 방법</h2>
                <p style="font-size: 0.75em; margin-bottom: 0.3em;">
                    3가지 방법으로 시작할 수 있습니다
                </p>
                <div class="install-box fragment fade-up">
                    <p style="font-size: 0.75em; margin: 0 0 0.15em 0; color: var(--ev-accent-light);"><strong>1. 원라인 설치 (권장)</strong></p>
                    <pre><code class="language-bash">curl -fsSL https://raw.githubusercontent.com/databricks-solutions/ai-dev-kit/main/install.sh | bash</code></pre>
                    <p style="font-size: 0.6em; color: var(--ev-text-muted); margin: 0.15em 0 0 0;">MCP 서버 + Skills + CLAUDE.md 한 번에 설정</p>
                </div>
                <div class="install-box fragment fade-up">
                    <p style="font-size: 0.75em; margin: 0 0 0.15em 0; color: var(--ev-accent-light);"><strong>2. 스타터 킷</strong></p>
                    <pre><code class="language-bash">git clone https://github.com/databricks-solutions/ai-dev-project
cd ai-dev-project && claude</code></pre>
                    <p style="font-size: 0.6em; color: var(--ev-text-muted); margin: 0.15em 0 0 0;">CLAUDE.md, MCP, Skills 포함 프로젝트 템플릿</p>
                </div>
                <div class="install-box fragment fade-up">
                    <p style="font-size: 0.75em; margin: 0 0 0.15em 0; color: var(--ev-accent-light);"><strong>3. Skills만 설치</strong></p>
                    <pre><code class="language-bash">cp -r ai-dev-kit/skills/databricks-skills/.claude/skills/* .claude/skills/</code></pre>
                    <p style="font-size: 0.6em; color: var(--ev-text-muted); margin: 0.15em 0 0 0;">기존 프로젝트에 Databricks Skills만 추가</p>
                </div>
                <aside class="notes">
                    AI Dev Kit를 시작하는 방법은 세 가지입니다.
                    첫째, curl 원라인 설치가 가장 간편합니다. MCP 서버, Skills, CLAUDE.md가 한 번에 설정됩니다.
                    둘째, 스타터 킷은 새 프로젝트를 시작할 때 유용합니다.
                    ai-dev-project 템플릿을 클론하면 CLAUDE.md, MCP 설정, Skills가 이미 포함되어 있습니다.
                    셋째, 기존 프로젝트가 있다면 Skills 디렉토리만 복사해서 추가할 수도 있습니다.
                    어떤 방법을 선택하든 5분 안에 시작할 수 있습니다.
                </aside>
            </section>

            <!-- Slide 10: [NEW] 빌드 가능한 것들 -->
            <section>
                <h2>AI Dev Kit로 빌드 가능한 것들</h2>
                <div class="columns">
                    <div>
                        <div class="mini-card fragment fade-up" data-fragment-index="0"><strong>DLT Pipelines</strong> &mdash; 데이터 파이프라인 자동 생성</div>
                        <div class="mini-card fragment fade-up" data-fragment-index="0"><strong>Workflows &amp; Jobs</strong> &mdash; 스케줄링 &amp; 오케스트레이션</div>
                        <div class="mini-card fragment fade-up" data-fragment-index="0"><strong>SQL Dashboards</strong> &mdash; AI 기반 대시보드 생성</div>
                        <div class="mini-card fragment fade-up" data-fragment-index="0"><strong>Genie Spaces</strong> &mdash; 자연어 데이터 분석</div>
                        <div class="mini-card fragment fade-up" data-fragment-index="0"><strong>Knowledge Articles</strong> &mdash; Genie 지식 베이스</div>
                    </div>
                    <div>
                        <div class="mini-card fragment fade-up" data-fragment-index="0"><strong>MLflow Experiments</strong> &mdash; ML 실험 관리</div>
                        <div class="mini-card fragment fade-up" data-fragment-index="0"><strong>Model Serving</strong> &mdash; 엔드포인트 배포</div>
                        <div class="mini-card fragment fade-up" data-fragment-index="0"><strong>Unity Catalog</strong> &mdash; 테이블 &amp; 스키마 관리</div>
                        <div class="mini-card fragment fade-up" data-fragment-index="0"><strong>ChatAgent Apps</strong> &mdash; 에이전트 앱 구축 &amp; 배포</div>
                    </div>
                </div>
                <aside class="notes">
                    AI Dev Kit로 빌드할 수 있는 것들을 나열해보면 정말 다양합니다.
                    DLT 파이프라인으로 데이터 엔지니어링을 자동화하고,
                    Workflows로 스케줄링과 오케스트레이션을 설정할 수 있습니다.
                    SQL 대시보드를 AI가 자동 생성하고, Genie Space로 자연어 데이터 분석도 가능합니다.
                    MLflow로 ML 실험을 관리하고, Model Serving으로 배포하고,
                    Unity Catalog로 거버넌스를 관리하고, ChatAgent로 에이전트 앱을 만들 수 있습니다.
                    오늘 배운 모든 개념이 이 안에 녹아있습니다.
                </aside>
            </section>

            <!-- Slide 11: ChatAgent 프레임워크 (기존 유지) -->
            <section>
                <h2>ChatAgent 프레임워크</h2>
                <p style="font-size: 0.85em; margin-bottom: 0.5em;">
                    <code>ChatAgent</code> &mdash; 모든 에이전트의 표준 인터페이스
                </p>
                <pre class="fragment fade-up"><code class="language-python">from databricks.agents import ChatAgent, ChatAgentResponse, ChatAgentMessage

class MyAgent(ChatAgent):
    """ChatAgent를 상속받아 에이전트를 구현합니다."""

    def predict(self, messages, context=None):
        """사용자 메시지를 받아 응답을 반환합니다."""
        user_message = messages[-1]["content"]

        # 여기에 에이전트 로직을 구현
        response = self._process(user_message)

        return ChatAgentResponse(
            messages=[
                ChatAgentMessage(role="assistant", content=response)
            ]
        )
</code></pre>
                <div class="fragment fade-up" style="margin-top: 0.8em;">
                    <div class="emphasis-box" style="font-size: 0.8em;">
                        <strong>핵심 포인트:</strong>
                        <code>predict()</code> 메서드 하나만 구현하면 로컬 테스트부터 프로덕션 배포까지 동일한 코드 사용
                    </div>
                </div>
                <aside class="notes">
                    ChatAgent 인터페이스의 핵심은 predict 메서드입니다.
                    ChatAgent 클래스를 상속받고 predict 메서드를 구현하는 것이 전부입니다.
                    messages 파라미터로 대화 히스토리가 들어오고,
                    ChatAgentResponse 객체로 응답을 반환합니다.
                    이 단순한 인터페이스 덕분에 어떤 LLM 프레임워크를 사용하든
                    (LangChain, LlamaIndex, 직접 구현 등) ChatAgent로 감싸면 됩니다.
                    로컬에서 테스트할 때도, Databricks에 배포할 때도 같은 코드가 사용됩니다.
                </aside>
            </section>

            <!-- Slide 12: predict() 상세 (기존 유지) -->
            <section>
                <h2><code>predict()</code> 메서드 상세</h2>
                <div class="columns">
                    <div>
                        <h3>입력: <code>messages</code></h3>
                        <pre><code class="language-python"># OpenAI 호환 메시지 형식
messages = [
    {
        "role": "user",
        "content": "매출 데이터를 분석해줘"
    }
]

# context: 추가 메타데이터
context = {
    "user_id": "user@company.com",
    "workspace": "production"
}
</code></pre>
                    </div>
                    <div>
                        <h3>출력: <code>ChatAgentResponse</code></h3>
                        <pre><code class="language-python">return ChatAgentResponse(
    messages=[
        ChatAgentMessage(
            role="assistant",
            content="분석 결과입니다..."
        )
    ]
)

# 도구 호출 결과도 포함 가능
# 스트리밍 응답 지원
# 멀티턴 대화 지원
</code></pre>
                    </div>
                </div>
                <div class="fragment fade-up" style="margin-top: 0.6em; text-align: center;">
                    <p style="font-size: 0.8em; color: var(--ev-text-muted);">
                        OpenAI 호환 메시지 형식 &rarr; 기존 코드와의 높은 호환성
                    </p>
                </div>
                <aside class="notes">
                    predict 메서드의 입출력을 자세히 살펴봅시다.
                    입력은 OpenAI 호환 메시지 형식입니다. role과 content로 구성된 딕셔너리 리스트죠.
                    context 파라미터는 선택적으로 사용할 수 있는 메타데이터입니다.
                    사용자 정보나 환경 정보를 전달하는 데 유용합니다.
                    출력은 ChatAgentResponse 객체로, 역시 OpenAI 호환 형식의 메시지를 담습니다.
                    이 호환성 덕분에 기존에 OpenAI API를 사용하던 코드를 쉽게 마이그레이션할 수 있습니다.
                </aside>
            </section>

            <!-- Slide 13: MLflow Tracing 연동 (기존 유지) -->
            <section>
                <h2>MLflow Tracing 연동</h2>
                <p style="font-size: 0.85em; margin-bottom: 0.6em;">
                    에이전트의 모든 동작을 <strong>자동으로 추적</strong>하고 시각화
                </p>
                <div class="tracing-box fragment fade-up">
                    <h4>1. <code>@mlflow.trace</code> 데코레이터</h4>
                    <p>함수 단위로 추적 포인트를 지정 &mdash; 입출력, 실행 시간 자동 기록</p>
                </div>
                <div class="tracing-box fragment fade-up">
                    <h4>2. 자동 추적 (autolog)</h4>
                    <p><code>mlflow.openai.autolog()</code> &mdash; OpenAI, LangChain 등 프레임워크 자동 연동</p>
                </div>
                <div class="tracing-box fragment fade-up">
                    <h4>3. 트레이스 UI</h4>
                    <p>MLflow UI에서 각 요청의 전체 호출 트리, 토큰 사용량, 지연 시간 확인</p>
                </div>
                <pre class="fragment fade-up"><code class="language-python">import mlflow

@mlflow.trace
def retrieve_context(query: str) -> list[str]:
    """검색 결과를 추적합니다."""
    results = vector_store.search(query, top_k=5)
    return [doc.content for doc in results]
</code></pre>
                <aside class="notes">
                    MLflow Tracing은 에이전트의 모든 동작을 추적하는 기능입니다.
                    세 가지 방법으로 사용할 수 있습니다.
                    첫째, @mlflow.trace 데코레이터를 함수에 붙이면 해당 함수의 입출력과 실행 시간이 자동 기록됩니다.
                    둘째, autolog를 활성화하면 OpenAI API 호출, LangChain 체인 실행 등이 자동으로 추적됩니다.
                    셋째, MLflow UI에서 각 요청의 전체 호출 트리를 시각적으로 확인할 수 있습니다.
                    예를 들어 RAG 에이전트의 경우, 검색 -> LLM 호출 -> 응답 생성의 전체 과정을 한눈에 볼 수 있습니다.
                </aside>
            </section>

            <!-- Slide 14: Tracing 적용 예시 (기존 유지) -->
            <section>
                <h2>Tracing 적용 예시</h2>
                <pre><code class="language-python">import mlflow
from openai import OpenAI

# 자동 추적 활성화 - OpenAI 호출이 자동으로 기록됨
mlflow.openai.autolog()

class MyAgent(ChatAgent):
    def __init__(self):
        self.client = OpenAI()

    @mlflow.trace(name="agent_predict")
    def predict(self, messages, context=None):
        # 1. 컨텍스트 검색 (추적됨)
        docs = self._retrieve(messages[-1]["content"])

        # 2. LLM 호출 (autolog로 자동 추적됨)
        response = self.client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": f"참고: {docs}"},
                *messages
            ]
        )

        return ChatAgentResponse(
            messages=[ChatAgentMessage(
                role="assistant",
                content=response.choices[0].message.content
            )]
        )

    @mlflow.trace(name="retrieve_context")
    def _retrieve(self, query: str) -> str:
        # 벡터 검색 로직
        return "검색된 문서 내용..."
</code></pre>
                <aside class="notes">
                    실제로 Tracing을 적용한 코드 예시입니다.
                    상단에서 mlflow.openai.autolog()를 호출하면 OpenAI API 호출이 자동으로 추적됩니다.
                    predict 메서드에 @mlflow.trace 데코레이터를 붙여 전체 처리 과정을 추적하고,
                    _retrieve 메서드에도 별도로 데코레이터를 붙여 검색 단계를 세분화해서 추적합니다.
                    이렇게 하면 MLflow UI에서 agent_predict 아래에 retrieve_context와 OpenAI 호출이
                    트리 구조로 표시되어 각 단계의 소요 시간과 입출력을 한눈에 확인할 수 있습니다.
                </aside>
            </section>

            <!-- Slide 15: 로컬 → 배포 흐름 (기존 유지) -->
            <section>
                <h2>로컬 개발 &rarr; Databricks 배포</h2>
                <div class="deploy-flow fragment fade-up">
                    <div class="flow-step">
                        <strong>로컬 개발</strong>
                        <span class="step-label">ChatAgent 구현<br>&amp; 테스트</span>
                    </div>
                    <span class="flow-arrow">&rarr;</span>
                    <div class="flow-step">
                        <strong>MLflow 로깅</strong>
                        <span class="step-label">모델 &amp; 트레이스<br>기록</span>
                    </div>
                    <span class="flow-arrow">&rarr;</span>
                    <div class="flow-step">
                        <strong>Model Serving</strong>
                        <span class="step-label">엔드포인트<br>배포</span>
                    </div>
                </div>
                <pre class="fragment fade-up"><code class="language-python"># Step 1: 로컬에서 테스트
agent = MyAgent()
response = agent.predict(
    messages=[{"role": "user", "content": "안녕하세요"}]
)
print(response.messages[0].content)
</code></pre>
                <pre class="fragment fade-up"><code class="language-python"># Step 2: MLflow로 모델 로깅
import mlflow

with mlflow.start_run():
    model_info = mlflow.pyfunc.log_model(
        artifact_path="agent",
        python_model=MyAgent(),
        pip_requirements=["databricks-agents", "openai"],
    )
</code></pre>
                <pre class="fragment fade-up"><code class="language-python"># Step 3: Databricks Model Serving으로 배포
from databricks.agents import deploy

deploy(
    model_uri=model_info.model_uri,
    endpoint_name="my-agent-endpoint"
)
</code></pre>
                <aside class="notes">
                    로컬 개발부터 Databricks 배포까지의 전체 흐름을 보겠습니다.
                    Step 1에서는 로컬에서 ChatAgent를 구현하고 predict를 직접 호출해서 테스트합니다.
                    Step 2에서는 테스트가 완료된 에이전트를 MLflow에 로깅합니다.
                    mlflow.pyfunc.log_model을 사용해서 에이전트 객체와 의존성을 함께 기록합니다.
                    Step 3에서는 databricks.agents의 deploy 함수 한 줄로 Model Serving 엔드포인트에 배포합니다.
                    이 세 단계가 AI Dev Kit의 핵심 워크플로우입니다.
                </aside>
            </section>

            <!-- Slide 16: 데모 - ChatAgent (기존 유지) -->
            <section>
                <h2>데모: ChatAgent 구현 <span class="badge">LIVE</span></h2>
                <p style="font-size: 0.85em; margin-bottom: 0.6em;">
                    간단한 Q&amp;A 에이전트를 만들고 로컬에서 테스트합니다
                </p>
                <pre><code class="language-python">import mlflow
from databricks.agents import ChatAgent, ChatAgentResponse, ChatAgentMessage
from openai import OpenAI

mlflow.openai.autolog()

class QAAgent(ChatAgent):
    """간단한 Q&A 에이전트"""

    def __init__(self):
        self.client = OpenAI()
        self.system_prompt = (
            "당신은 Databricks 관련 질문에 답변하는 도우미입니다. "
            "한국어로 친절하게 답변해주세요."
        )

    @mlflow.trace(name="qa_predict")
    def predict(self, messages, context=None):
        response = self.client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": self.system_prompt},
                *messages
            ]
        )
        return ChatAgentResponse(
            messages=[ChatAgentMessage(
                role="assistant",
                content=response.choices[0].message.content
            )]
        )

# 로컬 테스트
agent = QAAgent()
result = agent.predict(
    messages=[{"role": "user", "content": "Unity Catalog가 뭔가요?"}]
)
print(result.messages[0].content)
</code></pre>
                <aside class="notes">
                    데모 시간입니다. 간단한 Q&A 에이전트를 만들어보겠습니다.
                    QAAgent 클래스는 ChatAgent를 상속받고 predict 메서드를 구현합니다.
                    시스템 프롬프트로 Databricks 관련 질문에 한국어로 답변하도록 설정했습니다.
                    OpenAI API를 사용해서 응답을 생성하고, ChatAgentResponse로 감싸서 반환합니다.
                    mlflow.openai.autolog()와 @mlflow.trace 데코레이터로 전체 과정이 자동 추적됩니다.
                    로컬에서 predict를 직접 호출해서 테스트할 수 있습니다.
                    [실제 실행하여 결과를 보여주세요]
                </aside>
            </section>

            <!-- Slide 17: [NEW] 오늘 배운 것과 AI Dev Kit -->
            <section>
                <h2>오늘 배운 것 &rarr; AI Dev Kit</h2>
                <p style="font-size: 0.85em; margin-bottom: 0.6em;">
                    워크숍에서 학습한 개념이 AI Dev Kit에 그대로 적용됩니다
                </p>
                <div class="fragment fade-up" data-fragment-index="0">
                    <div class="mapping-row">
                        <span class="map-from">03. MCP 아키텍처</span>
                        <span class="map-arrow">&rarr;</span>
                        <span class="map-to">databricks-mcp (50+ 도구)</span>
                    </div>
                    <div class="mapping-row">
                        <span class="map-from">04. Genie MCP</span>
                        <span class="map-arrow">&rarr;</span>
                        <span class="map-to">query_genie_space 내장 도구</span>
                    </div>
                    <div class="mapping-row">
                        <span class="map-from">05. Skills</span>
                        <span class="map-arrow">&rarr;</span>
                        <span class="map-to">databricks-skills (25+ 스킬)</span>
                    </div>
                    <div class="mapping-row">
                        <span class="map-from">06. Custom Agents</span>
                        <span class="map-arrow">&rarr;</span>
                        <span class="map-to">ChatAgent 프레임워크</span>
                    </div>
                    <div class="mapping-row">
                        <span class="map-from">07. Hooks</span>
                        <span class="map-arrow">&rarr;</span>
                        <span class="map-to">프로젝트 설정 자동화</span>
                    </div>
                </div>
                <div class="fragment fade-up" style="margin-top: 0.8em;">
                    <div class="emphasis-box" style="font-size: 0.8em;">
                        오늘 배운 패턴들이 <strong style="color: var(--ev-accent);">프로덕션 수준</strong>으로 확장된 것이 AI Dev Kit입니다
                    </div>
                </div>
                <aside class="notes">
                    오늘 배운 내용과 AI Dev Kit의 연결 고리를 정리해봅시다.
                    Section 03에서 배운 MCP 아키텍처는 databricks-mcp의 50개 이상의 도구로 확장됩니다.
                    Section 04에서 직접 만든 Genie MCP는 이미 내장 도구로 포함되어 있습니다.
                    Section 05에서 배운 Skills 패턴은 25개 이상의 프로덕션 스킬로 확장됩니다.
                    Section 06의 Custom Agents 개념은 ChatAgent 프레임워크로 구체화됩니다.
                    Section 07의 Hooks는 프로젝트 설정 자동화에 활용됩니다.
                    오늘 배운 모든 패턴이 프로덕션 수준으로 확장된 것이 바로 AI Dev Kit입니다.
                </aside>
            </section>

            <!-- Slide 18: [NEW] 마무리 & Q&A -->
            <section>
                <h2>마무리 &amp; Q&amp;A</h2>
                <div class="emphasis-box">
                    <h3>오늘의 여정</h3>
                    <ul style="font-size: 0.85em;" class="fragment fade-up" data-fragment-index="0">
                        <li>
                            <strong>AI 기초</strong> &rarr; Claude Code &rarr; <strong>MCP</strong> &rarr; Genie MCP 서버 구현
                        </li>
                        <li>
                            <strong>Skills</strong> &rarr; Agents &rarr; Hooks &rarr; <strong>AI Dev Kit</strong>
                        </li>
                        <li>
                            Vibe Coding으로 <strong>프로덕션 수준의 AI 에이전트</strong>를 만들 수 있다는 것을 경험
                        </li>
                    </ul>
                </div>
                <div class="fragment fade-up" style="margin-top: 1.2em;">
                    <h3>리소스</h3>
                    <ul style="font-size: 0.8em;">
                        <li><a href="https://github.com/databricks-solutions/ai-dev-kit" style="color: var(--ev-accent-light);">github.com/databricks-solutions/ai-dev-kit</a></li>
                        <li><a href="https://docs.databricks.com/en/dev-tools/ai-dev-kit.html" style="color: var(--ev-accent-light);">Databricks AI Dev Kit 공식 문서</a></li>
                        <li><a href="https://mlflow.org/docs/latest/tracing.html" style="color: var(--ev-accent-light);">MLflow Tracing 공식 문서</a></li>
                    </ul>
                </div>
                <br>
                <p class="fragment fade-up" style="text-align: center; font-size: 1.3em; color: var(--ev-accent);">
                    감사합니다! 질문이 있으신가요?
                </p>
                <div class="nav-btn-group">
                    <a href="../../index.html" class="nav-btn nav-btn-primary">&larr; 홈으로 돌아가기</a>
                </div>
                <aside class="notes">
                    오늘의 여정을 돌아봅시다.
                    AI 기초에서 시작해 Claude Code, MCP 아키텍처를 배우고, Genie MCP 서버를 직접 만들었습니다.
                    Skills, Agents, Hooks로 Claude Code 확장 체계를 완성하고,
                    AI Dev Kit로 이 모든 것이 프로덕션 수준으로 확장되는 것을 보았습니다.
                    핵심 메시지는, Vibe Coding으로 프로덕션 수준의 AI 에이전트를 만들 수 있다는 것입니다.
                    여기 리소스 링크들을 참고하셔서 직접 시작해보시기 바랍니다.
                    감사합니다! 질문 받겠습니다.
                </aside>
            </section>

        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/notes/notes.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/highlight/highlight.js"></script>
    <script>
        Reveal.initialize({
            hash: true,
            slideNumber: true,
            plugins: [ RevealNotes, RevealHighlight ]
        });
    </script>
    <script src="../../shared/scripts/sidebar.js"></script>
    <script src="../../shared/scripts/copy-code.js"></script>
</body>
</html>
