<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>04 - Genie MCP - Enable Your Vibe</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reset.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/theme/black.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/highlight/monokai.css">
    <link rel="stylesheet" href="../../shared/assets/theme.css">
</head>
<body>
    <!-- Sidebar Navigation -->
    <button id="sidebar-toggle" class="sidebar-toggle"><span></span><span></span><span></span></button>
    <nav id="sidebar" class="sidebar">
        <div class="sidebar-header">
            <h2>Enable Your Vibe</h2>
            <p>Vibe Coding 핸즈온 세션</p>
        </div>
        <ul class="sidebar-sections"></ul>
    </nav>
    <div id="sidebar-overlay" class="sidebar-overlay"></div>

    <div class="reveal"><div class="slides">

        <!-- Slide 1: Title -->
        <section>
            <h1>Genie MCP</h1>
            <p>Genie MCP 서버 만들기</p>
            <p style="margin-top: 2em; font-size: 0.7em; color: var(--ev-text-muted);">
                Section 04 | Hands-on | 30분
            </p>
            <aside class="notes">
                이번 섹션에서는 Databricks Genie Space를 API로 직접 생성하고,
                이를 MCP 서버로 래핑하여 Claude Code에서 자연어로 데이터를 질의할 수 있는 환경을 구축합니다.
                Section 03에서 배운 MCP 아키텍처를 실제로 적용하는 핵심 실습입니다.
            </aside>
        </section>

        <!-- Slide 2: 학습 목표 -->
        <section>
            <h2>학습 목표</h2>
            <ul>
                <li class="fragment" data-fragment-index="0">Genie Space 생성 API와 serialized_space 형식을 이해한다</li>
                <li class="fragment" data-fragment-index="0">FastMCP로 Space 생성 + 질의 MCP 서버를 구현한다</li>
                <li class="fragment" data-fragment-index="0">Claude Code에서 Genie MCP를 연결하여 Space 생성 및 데이터 질의</li>
            </ul>
            <div class="emphasis-box fragment" data-fragment-index="0" style="margin-top: 1.5em;">
                <strong>핵심:</strong> Space 생성부터 질의까지 — Genie의 전체 라이프사이클을 API로 제어합니다
            </div>
            <aside class="notes">
                세 가지 학습 목표를 설명합니다.
                첫째, Genie Space를 API로 직접 생성하는 방법을 배웁니다. UI에서만 가능하던 것을 코드로 자동화합니다.
                둘째, 이 API를 FastMCP로 감싸서 MCP 서버를 만듭니다.
                셋째, 만든 서버를 Claude Code에 연결해서 Space 생성과 데이터 질의를 모두 수행합니다.
                핵심은 Genie의 전체 라이프사이클을 코드로 제어하는 것입니다.
            </aside>
        </section>

        <!-- Slide 3: Databricks Genie Space란? -->
        <section>
            <h2>Databricks Genie Space란?</h2>
            <div class="columns">
                <div>
                    <h3>자연어 데이터 질의 AI</h3>
                    <ul>
                        <li>자연어 질문을 SQL로 변환</li>
                        <li>Databricks 테이블에서 데이터 조회</li>
                        <li>결과를 자연어로 요약하여 반환</li>
                        <li>대화형 인터페이스 지원</li>
                    </ul>
                </div>
                <div>
                    <h3>활용 사례</h3>
                    <ul>
                        <li>"이번 달 매출 합계는?"</li>
                        <li>"가장 많이 팔린 상품 Top 5"</li>
                        <li>"지난 분기 대비 성장률"</li>
                        <li>"고객 이탈률 추이"</li>
                    </ul>
                </div>
            </div>
            <aside class="notes">
                Genie Space는 Databricks에서 제공하는 자연어 데이터 질의 인터페이스입니다.
                사용자가 자연어로 질문하면 내부적으로 SQL을 생성하고,
                Databricks 테이블에서 데이터를 조회한 뒤 결과를 반환합니다.
                웹 UI뿐 아니라 API를 통해서도 접근이 가능한데,
                이 API를 MCP 서버로 만들면 Claude Code에서 직접 데이터를 질의할 수 있게 됩니다.
            </aside>
        </section>

        <!-- Slide 4: Genie API 구조 -->
        <section>
            <h2>Genie API 구조</h2>
            <table>
                <thead>
                    <tr>
                        <th>기능</th>
                        <th>메서드</th>
                        <th>엔드포인트</th>
                    </tr>
                </thead>
                <tbody>
                    <tr class="fragment" data-fragment-index="0">
                        <td><strong>Space 생성</strong></td>
                        <td><code>POST</code></td>
                        <td><code>/api/2.0/genie/spaces</code></td>
                    </tr>
                    <tr class="fragment" data-fragment-index="0">
                        <td><strong>대화 생성</strong></td>
                        <td><code>POST</code></td>
                        <td><code>/api/2.0/genie/spaces/{id}/conversations</code></td>
                    </tr>
                    <tr class="fragment" data-fragment-index="0">
                        <td><strong>메시지 전송</strong></td>
                        <td><code>POST</code></td>
                        <td><code>.../conversations/{id}/messages</code></td>
                    </tr>
                    <tr class="fragment" data-fragment-index="0">
                        <td><strong>결과 조회</strong></td>
                        <td><code>GET</code></td>
                        <td><code>.../messages/{id}</code></td>
                    </tr>
                </tbody>
            </table>
            <div class="emphasis-box fragment" style="margin-top: 1em;">
                <strong>인증:</strong> Bearer 토큰 &mdash; <code>Authorization: Bearer {token}</code>
            </div>
            <aside class="notes">
                Genie API는 크게 두 부분으로 나뉩니다.
                먼저 Space 생성 API — POST /genie/spaces로 새 Space를 만듭니다.
                그 다음 질의 API — 대화 생성, 메시지 전송, 결과 조회의 3단계입니다.
                이번 실습에서는 Space 생성부터 질의까지 전체 흐름을 다룹니다.
                인증은 Databricks Personal Access Token을 Bearer 방식으로 사용합니다.
            </aside>
        </section>

        <!-- Slide 5: 전체 API 흐름 다이어그램 -->
        <section>
            <h2>전체 API 흐름</h2>
            <div class="diagram">
<pre style="background: transparent; border: none; box-shadow: none; text-align: center; font-size: 0.85em;">
Client                               Genie API
  |                                      |
  |  POST /genie/spaces                  |
  |    { title, warehouse_id,            |
  |     serialized_space }               |
  |------------------------------------->|
  |  { space_id }                        |
  |<-------------------------------------|
  |                                      |
  |  POST /spaces/{id}/conversations     |
  |------------------------------------->|
  |  { conversation_id }                 |
  |<-------------------------------------|
  |                                      |
  |  POST /conversations/{id}/messages   |
  |    { content: "Top 10 products?" }   |
  |------------------------------------->|
  |  { message_id }                      |
  |<-------------------------------------|
  |                                      |
  |  GET /messages/{id}  (polling)       |
  |------------------------------------->|
  |  { status: "COMPLETED", ... }        |
  |<-------------------------------------|
</pre>
            </div>
            <aside class="notes">
                전체 흐름을 보면: 먼저 Space를 생성하여 space_id를 받습니다.
                그 다음 대화를 시작하고, 질문을 보내고, 결과를 폴링합니다.
                Space 생성 시 serialized_space 필드가 핵심인데,
                이것은 테이블 정보, 지시사항, 예제 질문을 protobuf v2 JSON 형식으로 담고 있습니다.
                이 전체 흐름을 MCP 서버로 래핑할 것입니다.
            </aside>
        </section>

        <!-- Slide 6: 구현 전략 — 3개 Tool -->
        <section>
            <h2>MCP 서버 구현 전략: 3개 Tool</h2>
            <table>
                <thead>
                    <tr>
                        <th>Tool</th>
                        <th>기능</th>
                        <th>핵심 파라미터</th>
                    </tr>
                </thead>
                <tbody>
                    <tr class="fragment" data-fragment-index="1">
                        <td><code>create_genie_space</code></td>
                        <td>Space 생성</td>
                        <td>title, tables, instructions</td>
                    </tr>
                    <tr class="fragment" data-fragment-index="1">
                        <td><code>ask_genie</code></td>
                        <td>새 대화 + 질의</td>
                        <td>space_id, question</td>
                    </tr>
                    <tr class="fragment" data-fragment-index="1">
                        <td><code>continue_conversation</code></td>
                        <td>후속 질의</td>
                        <td>space_id, conversation_id, question</td>
                    </tr>
                </tbody>
            </table>
            <div class="emphasis-box fragment" style="margin-top: 1em;">
                <strong>설계 포인트:</strong> space_id를 파라미터로 받아 여러 Space를 유연하게 사용
            </div>
            <aside class="notes">
                MCP 서버는 3개의 tool을 제공합니다.
                create_genie_space는 새 Space를 생성합니다. 테이블 정보와 지시사항을 받아 serialized_space를 내부에서 구성합니다.
                ask_genie는 새 대화를 시작하고 질의합니다. 대화 생성, 메시지 전송, 폴링을 모두 내부에서 처리합니다.
                continue_conversation은 기존 대화에 후속 질문을 합니다.
                핵심 설계 포인트는 space_id를 환경변수가 아닌 파라미터로 받는 것입니다.
                이렇게 하면 여러 Space를 유연하게 사용할 수 있습니다.
            </aside>
        </section>

        <!-- ============================================================ -->
        <!-- Exercise 00: 사전 환경 체크리스트 -->
        <!-- ============================================================ -->

        <section>
            <h2>Exercise 00: 사전 환경 체크리스트</h2>
            <p style="font-size: 0.7em; color: var(--ev-text-muted);">실습 시작 전 환경 설정을 검증합니다</p>
            <pre><code class="language-bash" data-trim>databricks auth login --host https://e2-demo-field-eng.cloud.databricks.com -p e2-demo-field-eng
            </code></pre>
            <pre><code class="language-bash" data-trim>uv run python 04-genie-mcp/exercise_00_checklist.py
            </code></pre>
            <table style="font-size: 0.75em; margin-top: 0.8em;">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>검증 항목</th>
                        <th>방법</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>1</td>
                        <td>인증 정보 확인</td>
                        <td><code>.env</code> → <code>databricks CLI</code> → 기본값에서 자동 해석</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>호스트 연결</td>
                        <td><code>GET /api/2.0/clusters/spark-versions</code></td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>SQL Warehouse</td>
                        <td><code>SELECT 1</code> 실행 확인</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>데이터 스키마</td>
                        <td><code>shared.fashion_recommendations</code> 테이블 확인</td>
                    </tr>
                </tbody>
            </table>
            <div class="emphasis-box" style="margin-top: 0.8em;">
                모든 ✅ 확인 후 Exercise 01a로 진행하세요
            </div>
            <aside class="notes">
                실습을 시작하기 전에 환경이 올바르게 설정되었는지 확인합니다.
                exercise_00_checklist.py를 실행하면 4단계를 순차적으로 검증합니다.
                첫째, 인증 정보를 확인합니다. .env 파일이 있으면 그것을 사용하고, 없으면 databricks CLI 설정에서 자동으로 가져옵니다.
                WAREHOUSE_ID도 API로 자동 조회되므로, databricks CLI만 설정하면 별도 설정 없이 바로 실행 가능합니다.
                둘째, Databricks 호스트에 연결할 수 있는지 경량 API 호출로 확인합니다.
                셋째, SQL Warehouse가 작동하는지 SELECT 1로 확인합니다. 콜드스타트 시 시간이 걸릴 수 있습니다.
                넷째, shared.fashion_recommendations 스키마에 transactions, customers 테이블이 있는지 확인합니다.
                이전 단계가 실패하면 이후 단계는 자동으로 건너뜁니다. 모두 통과하면 Exercise 01a로 진행합니다.
            </aside>
        </section>

        <!-- ============================================================ -->
        <!-- Exercise 01a: Genie Space 생성 (Slides 7-11) -->
        <!-- ============================================================ -->

        <!-- Slide 7: serialized_space JSON 구조 -->
        <section>
            <h2>serialized_space JSON 구조</h2>
            <p style="font-size: 0.7em; color: var(--ev-text-muted);">Space 생성 API에 전달하는 protobuf v2 JSON 형식의 목표 출력</p>
            <pre><code class="language-json" data-trim data-noescape style="font-size: 0.8em; line-height: 1.4;">
{
  "version": 2,
  "data_sources": {
    "tables": [{"identifier": "catalog.schema.table"}]
  },
  "config": {
    "sample_questions": [{"id": "...", "question": ["질문 텍스트"]}]
  },
  "instructions": {
    "text_instructions": [
      {"id": "...", "content": ["지시사항 텍스트"]}
    ],
    "example_question_sqls": [
      {"id": "...", "question": ["질문"], "sql": ["SELECT ..."]}
    ],
    "join_specs": [ ... ],
    "sql_snippets": { "expressions": [...], "measures": [...], "filters": [...] }
  }
}
            </code></pre>
            <div class="emphasis-box fragment" style="margin-top: 0.8em;">
                이 구조를 코드로 생성합니다 &mdash; <code>build_serialized_space()</code>
            </div>
            <aside class="notes">
                이것이 Genie Space 생성 API에 전달하는 serialized_space의 전체 JSON 구조입니다.
                version 2는 protobuf v2 형식을 의미하며, Databricks 내부 프로토콜입니다.
                data_sources에는 테이블 정보, config에는 예제 질문, instructions에는 지시사항과 예제 SQL을 담습니다.
                join_specs와 sql_snippets는 선택 사항이지만 복잡한 데이터 모델에서 Genie의 SQL 품질을 향상시킵니다.
                이제 이 구조를 생성하는 코드를 단계별로 살펴보겠습니다.
            </aside>
        </section>

        <!-- Slide 7.5: JSON → Genie Space UI 매핑 -->
        <section>
            <h2>JSON → Genie Space UI 매핑</h2>
            <p style="font-size: 0.7em; color: var(--ev-text-muted);">
                serialized_space JSON의 각 필드가 Genie Space UI에 어떻게 반영되는지 확인
            </p>
            <div style="display: flex; gap: 1em; justify-content: center; align-items: flex-start; margin-top: 0.5em;">
                <!-- Data 탭 -->
                <div style="flex: 1; text-align: center;">
                    <img src="images/genie_data.png" alt="Genie Data Tab" style="max-height: 350px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);">
                    <p style="font-size: 0.55em; color: var(--ev-accent); margin-top: 0.4em;">
                        <code>data_sources.tables</code>
                    </p>
                </div>
                <!-- Instructions 탭 -->
                <div style="flex: 1; text-align: center;">
                    <img src="images/genie_instructions.png" alt="Genie Instructions Tab" style="max-height: 350px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);">
                    <p style="font-size: 0.55em; color: var(--ev-accent); margin-top: 0.4em;">
                        <code>instructions</code>
                    </p>
                </div>
                <!-- Settings 탭 -->
                <div style="flex: 1; text-align: center;">
                    <img src="images/genie_settings.png" alt="Genie Settings Tab" style="max-height: 350px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);">
                    <p style="font-size: 0.55em; color: var(--ev-accent); margin-top: 0.4em;">
                        <code>config</code> + title
                    </p>
                </div>
            </div>
            <aside class="notes">
                앞서 본 JSON 구조가 실제 Genie Space UI에 어떻게 반영되는지 시각적으로 확인해봅시다.
                Data 탭에는 data_sources.tables에 정의한 테이블들이 표시됩니다.
                Instructions 탭에는 text_instructions, example_question_sqls, join_specs, sql_snippets 등이 반영됩니다.
                Settings 탭에는 config.sample_questions로 설정한 예제 질문들과 title, description이 표시됩니다.
                이렇게 코드에서 정의한 JSON이 UI의 각 탭에 1:1로 매핑되므로, 코드만으로 Genie Space를 완전히 제어할 수 있습니다.
            </aside>
        </section>

        <!-- Slide 8: Step 1 — Space 설정 데이터 -->
        <section>
            <h2>Step 1: Space 설정 데이터</h2>
            <p style="font-size: 0.7em; color: var(--ev-text-muted);">테이블, 지시사항, 예제 질문/SQL, SQL 스니펫 정의</p>
            <pre><code class="language-python" data-trim data-noescape style="font-size: 0.8em; line-height: 1.4;">
tables = [
    {"catalog": "jongseob_demo", "schema": "fashion_recommendations", "table": "transactions"},
    {"catalog": "jongseob_demo", "schema": "fashion_recommendations", "table": "customers"},
]
instructions = [
    "## Sales Channel Mapping\n- `sales_channel_id = 1` means **Online** ...",
    # ...
]
sample_questions = [
    "How does revenue compare between online and in-store sales by month?",
    "What is the total online revenue for 2020?",
    "What are the monthly sales trends?",
    # ...
]
example_sqls = [
    {
        "question": "How does revenue compare between online and in-store sales by month?",
        "sql": "SELECT year, month, CASE WHEN ... FROM ...transactions GROUP BY ...",
    },
    # ...
]
sql_snippets = {
    "filters": [
        {
            "id": uuid4().hex,
            "sql": ["transactions.sales_channel_id = 1"],
            "display_name": "Online Sales Only",
            "synonyms": ["online", "web sales"]
        },
        # ...
    ],
    "expressions": [
        {
            "id": uuid4().hex,
            "alias": "transaction_month",
            "sql": ["transactions.month"],
            "display_name": "Transaction Month",
            "synonyms": ["month", "sale month"]
        },
        # ...
    ],
    "measures": [
        {
            "id": uuid4().hex,
            "alias": "total_revenue",
            "sql": ["CAST(SUM(transactions.price) AS DECIMAL(38,2))"],
            "display_name": "Total Revenue",
            "synonyms": ["revenue", "total sales"]
        },
        # ...
    ]
}
            </code></pre>
            <aside class="notes">
                먼저 Space에 넣을 설정 데이터를 정의합니다.
                tables는 Genie가 질의할 테이블 목록입니다. fashion_recommendations 스키마의 transactions, customers 2개 테이블을 사용합니다.
                instructions는 Genie에게 주는 지시사항입니다 — 컬럼 네이밍, 날짜 처리, 채널 매핑, 고객 세그먼트 가이드를 포함합니다.
                sample_questions는 5개의 예제 질문, example_sqls는 3개의 질문-SQL 쌍입니다.
                sql_snippets는 필터 5개, 표현식 3개, 측정값 4개를 포함합니다.
                슬라이드에서는 요약 표시하지만, 전체 코드는 exercise_01a_create_space.py에 있습니다.
            </aside>
        </section>

        <!-- Slide 9: Step 2 — build_serialized_space() -->
        <section>
            <h2>Step 2: build_serialized_space()</h2>
            <p style="font-size: 0.7em; color: var(--ev-text-muted);">설정 데이터를 protobuf v2 JSON으로 변환하는 함수</p>
            <pre><code class="language-python" data-trim data-noescape style="font-size: 0.8em; line-height: 1.4;">
def build_serialized_space(
    tables: list[dict],
    instructions: list[str],
    sample_questions: list[str],
    example_sqls: list[dict],
    join_specs: list[dict] | None = None,
    sql_snippets: dict | None = None,
) -> str:
    """Genie Space용 serialized_space(protobuf v2 JSON)를 생성합니다."""
    inst_block: dict = {
        "text_instructions": [
            {"id": uuid4().hex, "content": instructions}
        ] if instructions else [],
        "example_question_sqls": sorted(
            [{"id": uuid4().hex, "question": [ex["question"]], "sql": [ex["sql"]]}
             for ex in example_sqls],
            key=lambda x: x["id"],
        ),
    }

    if join_specs:
        inst_block["join_specs"] = join_specs

    if sql_snippets:
        sorted_snippets = {}
        for category, items in sql_snippets.items():
            sorted_snippets[category] = sorted(items, key=lambda x: x["id"])
        inst_block["sql_snippets"] = sorted_snippets

    proto = {
        "version": 2,
        "data_sources": {
            "tables": sorted(
                [{"identifier": f"{t['catalog']}.{t['schema']}.{t['table']}"} for t in tables],
                key=lambda x: x["identifier"],
            )
        },
        "config": {
            "sample_questions": sorted(
                [{"id": uuid4().hex, "question": [q]} for q in sample_questions],
                key=lambda x: x["id"],
            )
        },
        "instructions": inst_block,
    }
    return json.dumps(proto)
            </code></pre>
            <aside class="notes">
                build_serialized_space 함수는 앞에서 정의한 설정 데이터를 Genie API가 요구하는 protobuf v2 JSON 형식으로 변환합니다.
                text_instructions는 모든 지시사항을 하나의 항목으로 병합하고, 모든 id 기반 리스트를 정렬합니다.
                join_specs와 sql_snippets는 선택 사항이므로 있을 때만 포함합니다.
                최종적으로 json.dumps로 문자열로 변환하여 API에 전달할 준비를 합니다.
            </aside>
        </section>

        <!-- Slide 10: Step 3 — Space 생성 API 함수 -->
        <section>
            <h2>Step 3: create_genie_space()</h2>
            <p style="font-size: 0.7em; color: var(--ev-text-muted);">POST /api/2.0/genie/spaces로 Space를 생성하는 함수</p>
            <pre><code class="language-python" data-trim data-noescape style="font-size: 0.8em; line-height: 1.4;">
def create_genie_space(
    title: str, description: str, warehouse_id: str, serialized_space: str,
) -> dict:
    """POST /api/2.0/genie/spaces로 Space를 생성합니다."""
    resp = httpx.post(
        f"{DATABRICKS_HOST}/api/2.0/genie/spaces",
        headers=headers,
        json={
            "title": title, "description": description,
            "warehouse_id": warehouse_id, "serialized_space": serialized_space,
        },
    )
    resp.raise_for_status()
    return resp.json()
            </code></pre>
            <div class="emphasis-box fragment" style="margin-top: 1em;">
                <strong>핵심:</strong> <code>serialized_space</code>를 문자열로 전달 &mdash; JSON 안에 JSON 문자열
            </div>
            <aside class="notes">
                create_genie_space 함수는 POST /genie/spaces 엔드포인트를 호출합니다.
                title과 description은 Space의 메타정보이고,
                warehouse_id는 쿼리 실행에 사용할 SQL Warehouse입니다.
                serialized_space는 앞서 build_serialized_space로 생성한 JSON 문자열을 그대로 전달합니다.
                주의할 점은 serialized_space가 JSON 안에 문자열로 들어간다는 것입니다 — JSON 안에 JSON 문자열입니다.
                다음 슬라이드에서 main 함수의 실행 흐름을 보겠습니다.
            </aside>
        </section>

        <!-- Slide 11: Exercise 01a 실습 가이드 -->
        <section>
            <h2 style="font-size: 1.8em;">Exercise 01a: Space 생성 코드 실행</h2>
            <p style="font-size: 0.85em; color: var(--ev-text-muted);">exercise_01a_create_space.py &mdash; 완성 코드</p>
            <div style="text-align: left; margin: 0.8em auto; max-width: 95%;">
                <h3 style="font-size: 1.1em;">실습 단계</h3>
                <ol style="font-size: 0.9em; line-height: 1.6;">
                    <li class="fragment">코드를 읽고 주요 함수를 이해합니다: <br><code>build_serialized_space()</code>, <code>create_genie_space()</code></li>
                    <li class="fragment">코드를 실행합니다:
                        <pre style="margin: 0.4em 0;"><code class="language-bash" data-trim>
uv run python 04-genie-mcp/exercise_01a_create_space.py
                        </code></pre>
                    </li>
                    <li class="fragment">출력된 <code>Space ID</code>를 확인합니다</li>
                </ol>
            </div>
            <div class="emphasis-box fragment" style="margin-top: 0.8em; font-size: 1.05em;">
                출력된 <code>Space ID</code>를 exercise_01b에서 사용합니다
            </div>
            <aside class="notes">
                Exercise 01a는 완성 코드입니다. Claude Code 없이 바로 실행하여 Genie API가 정상 동작하는지 확인합니다.
                코드를 읽으면서 두 가지 핵심 함수를 이해합니다:
                첫째, build_serialized_space — 테이블/지시사항/예제를 protobuf v2 JSON으로 변환합니다.
                둘째, create_genie_space — POST /genie/spaces API를 호출합니다.
                실행 후 출력된 Space ID를 exercise_01b에서 사용합니다.
                API가 정상 동작하는 것을 확인한 후 Exercise 01b로 진행합니다.
            </aside>
        </section>

        <!-- ============================================================ -->
        <!-- Exercise 01b: Genie Space 질의 (Slides 12-14) -->
        <!-- ============================================================ -->

        <!-- Slide 14: Exercise 01b 질의 3단계 흐름 -->
        <section>
            <h2>Exercise 01b: 질의 3단계 흐름</h2>
            <p style="font-size: 0.7em; color: var(--ev-text-muted);">exercise_01b_query_space.py &mdash; 완성 코드</p>
            <div style="text-align: left; margin: 0.8em auto; max-width: 90%;">
                <div class="diagram">
<pre style="background: transparent; border: none; box-shadow: none; text-align: center; font-size: 0.75em;">
create_conversation()     send_message()       poll_result()
  대화 생성           →     질문 전송        →    결과 폴링
  conversation_id           message_id           COMPLETED
</pre>
                </div>
                <ul style="font-size: 0.65em; margin-top: 0.5em;">
                    <li><code>create_conversation</code> &mdash; <code>POST /spaces/{id}/conversations</code></li>
                    <li><code>send_message</code> &mdash; <code>POST /conversations/{id}/messages</code></li>
                    <li><code>poll_result</code> &mdash; <code>GET /messages/{id}</code> (점진적 백오프)</li>
                    <li><code>format_result</code> &mdash; 응답에서 텍스트/SQL 추출</li>
                </ul>
            </div>
            <aside class="notes">
                질의 흐름은 3단계입니다: 대화 생성, 질문 전송, 결과 폴링.
                코드에서 4개 함수의 역할을 이해합니다:
                create_conversation, send_message, poll_result, format_result.
                poll_result에서는 점진적 백오프 패턴을 사용합니다 — 1초에서 시작하여 1.5배씩 늘려 최대 5초까지 증가합니다.
            </aside>
        </section>

        <!-- Slide 15: Exercise 01b 실습 가이드 -->
        <section>
            <h2>Exercise 01b: Space 질의 코드 실행</h2>
            <p style="font-size: 0.8em; color: var(--ev-text-muted);">exercise_01b_query_space.py &mdash; 실습</p>
            <div style="text-align: left; margin: 1em auto; max-width: 85%;">
                <h3 style="font-size: 1em;">실습 단계</h3>
                <ol style="font-size: 0.85em;">
                    <li class="fragment">코드를 읽고 질의 3단계 흐름을 이해합니다</li>
                    <li class="fragment">exercise_01a에서 얻은 Space ID로 실행합니다:
                        <pre style="margin: 0.5em 0; font-size: 0.8em;"><code class="language-bash" data-trim>
uv run python 04-genie-mcp/exercise_01b_query_space.py &lt;SPACE_ID&gt;
                        </code></pre>
                    </li>
                    <li class="fragment">질의 결과를 확인합니다</li>
                </ol>
            </div>
            <div class="emphasis-box fragment" style="margin-top: 0.8em;">
                API 동작 확인 완료 &rarr; Exercise 02에서 MCP 서버로 래핑합니다
            </div>
            <aside class="notes">
                Exercise 01b도 완성 코드입니다. 바로 실행하여 Genie 질의 API가 정상 동작하는지 확인합니다.
                exercise_01a에서 출력된 Space ID를 커맨드라인 인자로 전달하여 실행합니다.
                01a와 01b에서 API 동작을 확인했으니, 이제 Exercise 02에서 이 로직을 MCP 서버로 래핑합니다.
            </aside>
        </section>

        <!-- ============================================================ -->
        <!-- Exercise 02: MCP 서버 (Slides 15-17) -->
        <!-- ============================================================ -->

        <!-- Slide 17: Exercise 02 MCP Tool 명세 -->
        <section>
            <h2>Exercise 02: MCP Tool 명세</h2>
            <p style="font-size: 0.7em; color: var(--ev-text-muted);">exercise_01a/01b를 기반으로 MCP 서버 구현</p>
            <div style="text-align: left; margin: 0.8em auto; max-width: 90%;">
                <table style="font-size: 0.65em; margin-top: 0.5em;">
                    <thead>
                        <tr>
                            <th>Tool</th>
                            <th>주요 파라미터</th>
                            <th>내부 로직</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>create_genie_space</code></td>
                            <td>title, tables, instructions, ...</td>
                            <td><code>_build_serialized_space</code> + <code>POST /genie/spaces</code></td>
                        </tr>
                        <tr>
                            <td><code>ask_genie</code></td>
                            <td>space_id, question</td>
                            <td>대화 생성 + <code>_send_and_poll</code></td>
                        </tr>
                        <tr>
                            <td><code>continue_conversation</code></td>
                            <td>space_id, conversation_id, question</td>
                            <td><code>_send_and_poll</code> (기존 대화 이어가기)</td>
                        </tr>
                    </tbody>
                </table>
                <p style="font-size: 0.65em; color: var(--ev-text-muted); margin-top: 0.5em;">
                    헬퍼: <code>_build_serialized_space()</code>, <code>_send_and_poll()</code>, <code>_format_response()</code>
                </p>
            </div>
            <div class="emphasis-box" style="margin-top: 0.8em;">
                Exercise 01a/01b의 완성 코드가 레퍼런스 &mdash; 동일 로직을 <code>@mcp.tool()</code>로 래핑
            </div>
            <aside class="notes">
                Exercise 02에서 구현할 MCP 서버의 Tool 명세입니다.
                3개의 MCP tool(create_genie_space, ask_genie, continue_conversation)과
                3개의 헬퍼 함수(_build_serialized_space, _send_and_poll, _format_response)로 구성됩니다.
                Exercise 01a/01b에서 이미 동작을 확인한 API 로직을 그대로 사용하되,
                @mcp.tool() 데코레이터로 래핑하는 것이 핵심입니다.
            </aside>
        </section>

        <!-- Slide 18: Exercise 02 실습 단계 -->
        <section>
            <h2>Exercise 02: 실습 가이드</h2>
            <p style="font-size: 0.7em; color: var(--ev-text-muted);">Claude Code로 MCP 서버 코딩 실습</p>
            <div style="text-align: left; margin: 0.8em auto; max-width: 90%;">
                <ol style="font-size: 0.7em;">
                    <li class="fragment">스켈레톤 파일의 TODO 확인: <code>exercise_02_genie_mcp_server.py</code></li>
                    <li class="fragment">Claude Code에게 구현 요청:
                        <pre style="margin: 0.5em 0; font-size: 0.8em;"><code class="language-text" data-trim>
@04-genie-mcp/ exercise_01a, 01b를 참고해서 exercise_02의 MCP 서버를 완성해줘
                        </code></pre>
                    </li>
                    <li class="fragment">실행 및 테스트:
                        <pre style="margin: 0.5em 0; font-size: 0.8em;"><code class="language-bash" data-trim>
uv run python 04-genie-mcp/exercise_02_genie_mcp_server.py
                        </code></pre>
                    </li>
                </ol>
            </div>
            <aside class="notes">
                Exercise 02는 이번 섹션의 핵심 코딩 실습입니다.
                스켈레톤 파일에 3개 MCP tool과 3개 헬퍼 함수의 TODO가 있고,
                각 TODO에는 01a/01b의 어떤 함수를 참고하면 되는지 명시되어 있습니다.
                Claude Code에게 "exercise_01a, 01b를 참고해서 exercise_02의 MCP 서버를 완성해줘"라고 요청합니다.
                실행하면 MCP 서버가 시작되어 Claude Code에서 연결할 수 있습니다.
            </aside>
        </section>

        <!-- ============================================================ -->
        <!-- 마무리 (Slides 18-19) -->
        <!-- ============================================================ -->

        <!-- Slide 18: Claude Code 연결 + 실습 안내 -->
        <section>
            <h2>Claude Code 연결 + 실습 안내</h2>
            <div style="display: flex; align-items: flex-start; gap: 1em;">
                <div style="flex: 1;">
                    <h3>① .mcp.json 설정</h3>
                    <pre><code class="language-bash" data-trim># 프로젝트 루트의 .mcp.json에 추가
cat > .mcp.json << 'EOF'
{
  "mcpServers": {
    "genie": {
      "type": "stdio",
      "command": "uv",
      "args": ["run", "python", "04-genie-mcp/exercise_02_genie_mcp_server.py"]
    }
  }
}
EOF</code></pre>
                </div>
                <div style="flex: 0.7;">
                    <h3>② Claude Code 재시작</h3>
                    <pre><code class="language-bash" data-trim># Claude Code 종료 후 다시 실행
/exit
claude</code></pre>
                    <h3 style="margin-top: 1em;">③ 연결 확인</h3>
                    <pre><code class="language-bash" data-trim>/mcp</code></pre>
                    <p style="font-size: 0.8em; color: var(--ev-text-muted);">
                        genie 서버가 목록에<br>표시되면 성공!
                    </p>
                </div>
            </div>
            <div class="emphasis-box" style="margin-top: 0.8em;">
                <strong>실습 워크플로우:</strong> Exercise 00 체크리스트 → 01a 실행 (Space 생성) → 01b 실행 (질의 확인) → 02 Claude Code로 MCP 서버 구현 → Claude Code에 MCP 연결
            </div>
            <aside class="notes">
                Claude Code에서 사용하려면 프로젝트 루트의 .mcp.json에 MCP 서버를 등록합니다.
                설정을 저장한 뒤 Claude Code를 재시작해야 새 서버가 로드됩니다.
                /mcp 명령어를 실행하면 등록된 MCP 서버 목록과 연결 상태를 확인할 수 있습니다.
                genie가 목록에 보이면 정상적으로 연결된 것입니다.
                실습 워크플로우는 다음과 같습니다:
                먼저 Exercise 00으로 환경을 검증합니다.
                Exercise 01a를 실행하여 Space를 생성하고, 01b를 실행하여 질의 API를 확인합니다.
                API 동작이 확인되면 Exercise 02에서 Claude Code로 MCP 서버를 구현합니다.
                마지막으로 Exercise 02의 MCP 서버를 Claude Code에 연결하여 자연어로 전체 워크플로우를 수행합니다.
            </aside>
        </section>

        <!-- Slide 19: 대화 예시 -->
        <section>
            <h2>대화 예시</h2>
            <div class="emphasis-box" style="font-size: 0.85em;">
                <p><strong>사용자:</strong> "Fashion Recommendations 데이터로 Genie Space를 만들어줘"</p>
                <p><strong>Claude:</strong> <code>create_genie_space</code> tool로 Space를 생성합니다.</p>
                <p style="margin-top: 0.5em;"><strong>사용자:</strong> "매출 Top 10 상품을 알려줘"</p>
                <p><strong>Claude:</strong> <code>ask_genie</code> tool로 질의합니다.</p>
                <p style="margin-top: 0.5em;"><strong>사용자:</strong> "온라인/오프라인별로 나눠서 보여줘"</p>
                <p><strong>Claude:</strong> <code>continue_conversation</code> tool로 후속 질의합니다.</p>
            </div>
            <aside class="notes">
                등록 후 Claude Code에서 Space 생성을 요청하면 create_genie_space tool이 호출됩니다.
                생성된 Space에 질문하면 ask_genie tool이, 후속 질문은 continue_conversation tool이 호출됩니다.
            </aside>
        </section>

        <!-- Slide 20: 정리 & Q&A -->
        <section>
            <h2>정리 & Q&A</h2>
            <ul>
                <li><strong>Space 생성 API</strong>: serialized_space(protobuf v2)로 테이블/지시사항 정의</li>
                <li><strong>질의 API</strong>: 대화 생성 &rarr; 메시지 전송 &rarr; 점진적 백오프 폴링</li>
                <li><strong>3개 Tool MCP</strong>: create_genie_space + ask_genie + continue_conversation</li>
                <li><strong>Claude Code 연동</strong>: Space 생성부터 질의까지 자연어로 수행</li>
            </ul>
            <div class="emphasis-box" style="margin-top: 1.5em;">
                <strong>다음 섹션:</strong> Skills &mdash; 개념에서 실전까지, Skill을 직접 만들어봅니다
            </div>
            <aside class="notes">
                이번 섹션의 핵심을 정리합니다.
                Genie Space를 API로 직접 생성하는 방법과 serialized_space의 protobuf v2 형식을 배웠습니다.
                질의 API의 3단계 구조와 점진적 백오프 폴링 패턴을 이해했습니다.
                이를 3개의 MCP tool로 래핑하여 Claude Code에서 전체 워크플로우를 자연어로 수행할 수 있게 했습니다.
                이 패턴은 Genie뿐 아니라 다른 Databricks API나 외부 서비스를 MCP로 만들 때도 동일하게 적용됩니다.
                질문이 있으시면 자유롭게 해주세요.
            </aside>
        </section>

    </div></div>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/notes/notes.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/highlight/highlight.js"></script>
    <script>
        Reveal.initialize({ hash: true, slideNumber: true, plugins: [RevealNotes, RevealHighlight] });
    </script>
    <script src="../../shared/scripts/sidebar.js"></script>
    <script src="../../shared/scripts/copy-code.js"></script>
</body>
</html>
